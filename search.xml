<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript中数组的使用及方法</title>
    <url>/2023/03/13/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E7%9A%8430%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><font face="微软雅黑" size=5><strong>什么是数组</strong></font><br>数组对象是使用单独的变量名来存储一系列的值。简单意思就是普通变量一次只能储存一个值，数组可以储存多个值<br>如果你有一组数据（例如：车名字），存在单独变量如下所示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var car1=&quot;奔驰&quot;;<br>var car2=&quot;奥迪&quot;;<br>var car3=&quot;宝马&quot;;<br></code></pre></td></tr></table></figure>
<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p><font face="微软雅黑" size=5><strong>创建一个数组有3种方式</strong></font><br><strong>方式一 : 常规方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var myCars = new Array();<br>myCars[0]=&quot;奔驰&quot;<br>myCars[1]=&quot;奥迪&quot;<br>myCars[2]=&quot;宝马&quot;<br></code></pre></td></tr></table></figure>
<p><strong>方式二 : 简洁方式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var myCars=new Array(&quot;奔驰&quot;,&quot;奥迪&quot;,&quot;宝马&quot;);<br></code></pre></td></tr></table></figure>
<p><strong>方式三 : 字面 (常用)</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var myCars=[&quot;奔驰&quot;,&quot;奥迪&quot;,&quot;宝马&quot;];<br></code></pre></td></tr></table></figure>

<h2 id="数组的属性"><a href="#数组的属性" class="headerlink" title="数组的属性"></a>数组的属性</h2><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p><strong>返回创建数组对象原型的函数</strong><br>返回myCars数组对象原型创建的函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var myCars = [&quot;奔驰&quot;, &quot;奥迪&quot;, &quot;宝马&quot;]<br>myCars.constructor<br></code></pre></td></tr></table></figure>
<p><strong>结果输出:</strong></p>
<blockquote>
<p>function Array() { [native code] }</p>
</blockquote>
<p><strong>在JavaScript中，constructor属性返回对象的构造函数。</strong><br><strong>返回值是函数的引用，不是函数名:</strong></p>
<blockquote>
<p>JavaScript 数组 constructor 属性返回 function Array() { [native code] }<br>JavaScript 数字 constructor 属性返回 function Number() { [native code] }<br>JavaScript 字符串 constructor 属性返回 function String() { [native code] }</p>
</blockquote>
<h3 id="lenght"><a href="#lenght" class="headerlink" title="lenght"></a>lenght</h3><p><strong>设置或返回数组元素的个数。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var myCars = [&quot;奔驰&quot;, &quot;奥迪&quot;, &quot;宝马&quot;]<br>myCars.length<br></code></pre></td></tr></table></figure>
<p><strong>结果输出:</strong></p>
<blockquote>
<p>3</p>
</blockquote>
<p><strong>设置数组的数目：array.length=number</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var myCars = [&quot;奔驰&quot;, &quot;奥迪&quot;, &quot;宝马&quot;]<br>myCars.length=10<br>console.log(myCars.length) <br>console.log(myCars) <br>console.log(myCars[5])<br></code></pre></td></tr></table></figure>
<p><strong>结果输出:</strong></p>
<blockquote>
<p>10<br>[“奔驰”, “奥迪”, “宝马”, empty × 7] &emsp; &emsp; &emsp; 后面为空值<br>undefined</p>
</blockquote>
<h3 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h3><p><strong>允许你向数组对象添加属性或方法</strong><br><strong>添加一个新的数组的方法，将数组值转为大写：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits=[&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;]<br>Array.prototype.myUcase = function () &#123;<br>    for (i = 0; i &lt; this.length; i++) &#123;<br>        this[i] = this[i].toUpperCase();      //toUpperCase() 方法用于把字符串转换为大写<br>    &#125;<br>&#125;<br>fruits.myUcase();<br></code></pre></td></tr></table></figure>
<p><strong>结果输出:</strong></p>
<blockquote>
<p>[“BANANA”, “ORANGE”, “APPLE”, “MANGO”]</p>
</blockquote>
<h2 id="Array-对象方法"><a href="#Array-对象方法" class="headerlink" title="Array 对象方法"></a>Array 对象方法</h2><p><strong>数组总共有30种方法</strong></p>
<h3 id="不改变原数组"><a href="#不改变原数组" class="headerlink" title="不改变原数组"></a>不改变原数组</h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p><strong>把数组转换为字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 2, 3, 4]<br>var sum = arr.toString()<br>console.log(sum)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果 :</strong></p>
<blockquote>
<p>1,2,3,4,     字符串类型</p>
</blockquote>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p><strong>连接两个或更多的数组，并返回结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits1 = [&quot;Banana&quot;, &quot;Orange&quot;,]<br>var fruits2 = [&quot;Apple&quot;,&quot;Mango&quot;,]<br>var fruits3 = [&quot;watermelon&quot;,&quot;pear&quot;,]<br>var fruits = fruits1.concat(fruits2,fruits3)<br></code></pre></td></tr></table></figure>
<p><strong>fruits 输出结果:</strong></p>
<blockquote>
<p> [“Banana”, “Orange”, “Apple”, “Mango”, “watermelon”, “pear”]</p>
</blockquote>
<h4 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h4><p><strong>返回数组的可迭代对象</strong><br><strong>简单说就是 Object.entries() 可以把一个对象的键值以数组的形式遍历出来，迭代对象中数组的索引值作为 key，数组元素作为 value。结果和 for…in 一致，但不会遍历原型属性</strong><br><strong>1. 传入对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var obj = &#123;name: &#x27;雏田&#x27;,age: 18&#125;<br>var x = Object.entries(obj)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果:</strong></p>
<blockquote>
<p>[[‘name’, ‘雏田’], [‘age’, 18]]</p>
</blockquote>
<p><strong>2. 传入数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr =  [&quot;鸣人&quot;, &quot;雏田&quot;, &quot;佐助&quot;]; <br>var x = Object.entries(arr)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果:</strong></p>
<blockquote>
<p>[[‘0’, “鸣人”], [‘1’, ‘雏田’], [‘2’, ‘佐助’]]</p>
</blockquote>
<p><strong>3. 传入数组中包含对象</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr =  [&#123;name:&quot;鸣人&quot;&#125;, &quot;雏田&quot;, &quot;佐助&quot;]; <br>var x = Object.entries(arr)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果:</strong></p>
<blockquote>
<p>[[‘0’, { name: “鸣人” }], [‘1’, ‘雏田’], [‘2’, ‘佐助’]]</p>
</blockquote>
<p><strong>4. 传入字符串</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var string =  &quot;123&quot; <br>var x = Object.entries(string)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果:</strong></p>
<blockquote>
<p>[[“0”, “1”], [“1”, “2”], [“2”, “3”]]</p>
</blockquote>
<p><strong>5. 传入数字，浮点数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var number =  123 <br>var number1 =  123.3 <br>var x = Object.entries(number)<br>var y = Object.entries(number1)<br></code></pre></td></tr></table></figure>
<p><strong>x y输出结果:</strong></p>
<blockquote>
<p>都为 [ ]</p>
</blockquote>
<h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p><strong>检测数值元素的每个元素是都否都符合条件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var number = [2, 34, 45, 1]<br>var x = number.every((i) =&gt;<br>    i &gt; 30<br>)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果:</strong></p>
<blockquote>
<p>false</p>
</blockquote>
<h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p><strong>检测数组元素中是否有元素符合指定条件</strong><br><strong>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测</strong><br><strong>如果没有满足条件的元素，则返回false</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var number = [2, 34, 45, 1]<br>var x = number.some((i) =&gt;<br>    i &gt; 30<br>)<br>console.log(x)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果</strong></p>
<blockquote>
<p>true</p>
</blockquote>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p><strong>检测数值元素，并返回符合条件所有元素的数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var number = [2, 34, 45, 1]<br>var x = number.filter((i) =&gt;<br>    i &gt; 30<br>)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果:</strong></p>
<blockquote>
<p>[34, 45]</p>
</blockquote>
<h4 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h4><p><strong>返回符合传入测试（函数）条件的数组元素</strong><br><strong>获取数组中年龄大于 30 的第一个元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var number = [2, 34, 45, 1]<br>var x = number.find((i) =&gt;<br>    i &gt; 30<br>)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果:</strong></p>
<blockquote>
<p>34</p>
</blockquote>
<h4 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex()"></a>findIndex()</h4><p><strong>返回符合传入测试（函数）条件的数组元素索引</strong><br>获取数组中年龄大于等于 30 的第一个元素索引位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var number = [2, 34, 45, 1]<br>var x = number.findIndex((i) =&gt;<br>    i &gt; 30<br>)<br></code></pre></td></tr></table></figure>
<p><strong>x 输出结果:</strong></p>
<blockquote>
<p>1</p>
</blockquote>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p><strong>遍历数组中的每一位</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;];<br>var a = &quot;&quot;;<br>var b = 0;<br>arr.forEach((value, index, array) =&gt; &#123;<br>  console.log(value)<br>  console.log(index)<br>  console.log(array)<br>  console.log(array[index])<br>  a += (array[index])<br>  b += index<br>    &#125;)<br>console.log(a)<br>console.log(b)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>a b c d e f<br>0 1 2 3 4 5<br>[“a”, “b”, “c”, “d”, “e”, “f”] * 6<br>a b c d e f<br>abcdef<br>15</p>
</blockquote>
<p><font size=5>forEach() 的 continue 与 break</font></p>
<p><strong>forEach() 本身是不支持的 <code>continue</code> 与 <code>break</code> 语句的，我们可以通过 <code>some</code> 和 <code>every</code> 来实现</strong><br><strong>continue 实现</strong><br><strong>使用 return 语句实现 continue 关键字的效果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 2, 3, 4, 5];<br>arr.forEach(function (item) &#123;<br>    console.log(item)<br>    if (item === 3) &#123;<br>        return;       //3的元素跳过<br>    &#125;<br>    console.log(item);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>1 2 3 4 5<br>1 2 4 5</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 2, 3, 4, 5];<br>arr.some(function (item) &#123;<br>    if (item === 2) &#123;<br>        return;     // 不能为 return false<br>    &#125;<br>    console.log(item);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>1 3 4 5</p>
</blockquote>
<p><strong>break 实现</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 2, 3, 4, 5];<br>arr.every(function (item) &#123;<br>        console.log(item);<br>        return item !== 3;<br>        console.log(&quot;我被终止了&quot;)<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>1 2 3<br>不执行</p>
</blockquote>
<h4 id="from"><a href="#from" class="headerlink" title="from()"></a>from()</h4><p><strong><code>语法 : Array.from(object, mapFunction, thisValue)</code></strong><br><code>object : 必需，要转换为数组的对象</code><br><code>mapFunction : 可选，数组中每个元素要调用的函数</code><br><code>thisValue : 可选，映射函数(mapFunction)中的 this 对象</code><br><strong>通过给定的对象中创建一个数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = Array.from(&quot;RUNOOB&quot;)<br>console.log(arr)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>[“R”, “U”, “N”, “O”, “O”, “B”]<br><strong>下面的实例返回集合中包含的对象数组</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var setObj = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);<br>var objArr = Array.from(setObj);<br>console.log(objArr[1] == &quot;b&quot;)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>true<br><strong>下面的实例演示如何使用箭头语法和映射函数更改元素的值</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = Array.from([1, 2, 3], x =&gt; x * 10);<br>console.log(arr[0]) <br>console.log(arr[1]) <br>console.log(arr[2]) <br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>10<br>20<br>30</p>
</blockquote>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p><strong>判断一个数组是否包含一个指定的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;pear&quot;]<br>fruits.includes(&quot;Banana&quot;) <br>fruits.includes(&quot;哈粒嘎&quot;)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<h4 id="isArray"><a href="#isArray" class="headerlink" title="isArray()"></a>isArray()</h4><p><strong>判断对象是否为数组：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var obj = &#123;id:&quot;Banana&quot;&#125;<br>var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;pear&quot;]<br>console.log(Array.isArray(fruits))<br>console.log(Array.isArray(obj)) <br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>true<br>false</p>
</blockquote>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p><strong>将数组转换为字符串拼接数组</strong><br><strong>里面的参数必须时字符串类型 —–&gt;返回字符串类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>var fruits1 = fruits.join();<br>var fruits2 = fruits.join(&quot;~&quot;);<br>console.log(fruits1)<br>console.log(fruits2)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>Banana,Orange,Apple,Mango<br>Banana<del>Orange</del>Apple~Mango</p>
</blockquote>
<h4 id="keys"><a href="#keys" class="headerlink" title="keys()"></a>keys()</h4><p><strong>返回一个数组索引的迭代器</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [&quot;a&quot;, &quot;b&quot;,&quot;c&quot;];   //传入对象<br>var obj = &#123;a:123,b:345&#125;     //传入数组<br>var str = &#x27;ab1234&#x27;;         //传入字符串<br>console.log(Object.keys(obj))<br>console.log(Object.keys(arr))<br>console.log(Object.keys(str))<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>[“a”, “b”]<br>[“0”, “1”, “2”]<br>[“0”, “1”, “2”, “3”, “4”, “5”]</p>
</blockquote>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p><strong>搜索数组中的元素，并返回它所在的位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>var fruits1=[&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;];<br>var a = fruits.indexOf(&quot;Apple&quot;);<br>var b = fruits1.indexOf(&quot;Apple&quot;);<br>console.log(a)<br>console.log(b)<br></code></pre></td></tr></table></figure>
<p><strong>输出 a b 结果:</strong></p>
<blockquote>
<p>2<br>2</p>
</blockquote>
<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p><strong>搜索数组中的元素，并返回它最后出现的位置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>var fruits1=[&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;];<br>var a = fruits.lastIndexOf(&quot;Apple&quot;);<br>var b = fruits1.lastIndexOf(&quot;Apple&quot;);<br>console.log(a)<br>console.log(b)<br></code></pre></td></tr></table></figure>
<p><strong>输出 a b 结果:</strong></p>
<blockquote>
<p>2<br>6</p>
</blockquote>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><strong>对数组的每个元素调用定义的回调函数并返回包含结果的数组</strong><br><strong><code>语法 : array.map(function(currentValue,index,arr), thisValue)</code></strong><br><code>currentValue : 必须。当前元素的值</code><br><code>index : 可选。当前元素的索引值</code><br><code>arr : 可选。当前元素属于的数组对象</code><br><code>thisValue : 可选。对象作为该执行回调时使用，传递给函数，用作 &quot;this&quot; 的值。如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 3, 4, 6];<br>//Es5写法<br>let num = arr.map(function (value, index, array) &#123;<br>    console.log(value)<br>    console.log(index)<br>    console.log(array)<br>    return value * 3;<br>&#125;)<br>console.log(num)<br>//ES6箭头函数写法<br>let newNum = arr.map((value, index, array) =&gt; value * 3)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>1 3 4 6<br>0 1 2 3<br>[1, 3, 4, 6]*4<br>[3, 9, 12, 18]</p>
</blockquote>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p><strong>选取数组的一部分，并返回一个新数组</strong><br><strong><code>array.slice(start, end)</code></strong><br><code>start(从该位开始截取) : 可选。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。如果该参数为负数，则表示从原数组中的倒数第几个元素开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）</code><br><code>end(截取该位结束) : 可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 slice(-2,-1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）</code><br><strong>1个参数时：从该位截取，一直截取到最后</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Lemon&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>var citrus = fruits.slice(2);<br>var citrus1 = fruits.slice(1,3)<br>console.log(fruits)<br>console.log(citrus)<br>console.log(citrus1)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>[“Banana”, “Orange”, “Lemon”, “Apple”, “Mango”]<br>[“Lemon”, “Apple”, “Mango”]<br> [“Orange”, “Lemon”]</p>
</blockquote>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p><strong>将数组元素计算为一个值（从左到右）</strong><br><strong><code>语法: array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</code></strong><br><code>total : 必需。初始值, 或者计算结束后的返回值</code><br><code>currentValue : 必需。当前元素</code><br><code>currentIndex : 可选。当前元素的索引</code><br><code>arr : 可选。当前元素所属的数组对象</code><br><code>initialValue : 可选。传递给函数的初始值</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 3, 5, 7, 9];<br>var x = arr.reduce(function (x, y) &#123;<br>    return x + y;<br>&#125;);<br>var y = arr.reduce(function (x, y) &#123;<br>    return x * 10 + y;<br>&#125;);<br>console.log(arr)<br>console.log(x)<br>console.log(y)<br></code></pre></td></tr></table></figure>
<p><strong>执行结果</strong></p>
<blockquote>
<p>[1, 3, 5, 7, 9]<br>25<br>13579</p>
</blockquote>
<h4 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h4><p><strong>将数组元素计算为一个值（从右到左）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 3, 5, 7, 9];<br>var x = arr.reduceRight(function (x, y) &#123;<br>    return x + y;<br>&#125;);<br>var y = arr.reduceRight(function (x, y) &#123;<br>    return x * 10 + y;<br>&#125;); <br>console.log(arr)<br>console.log(x)<br>console.log(y)<br></code></pre></td></tr></table></figure>
<p><strong>执行结果 :</strong></p>
<blockquote>
<p>[1, 3, 5, 7, 9]<br>25<br>97531</p>
</blockquote>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><p><strong>返回数组对象的原始值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>var x=fruits.valueOf();<br>console.log(x)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>[“Banana”, “Orange”, “Apple”, “Mango”]     fruits.valueOf()与 fruits返回值一样</p>
</blockquote>
<h3 id="改变原数组"><a href="#改变原数组" class="headerlink" title="改变原数组"></a>改变原数组</h3><h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin()"></a>copyWithin()</h4><p><strong><code>语法: array.copyWithin(target, start, end)</code></strong><br><code>target : 必需。复制到指定目标索引位置</code><br><code>start : 可选。元素复制的起始位置</code><br><code>end : 可选。停止复制的索引位置 (默认为 array.length)。如果为负值，表示倒数</code><br><strong>从数组的指定位置拷贝元素到数组的另一个指定位置中</strong><br><strong>复制数组的前面两个元素到后面两个元素上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;pear&quot;]<br>fruits.copyWithin(2, 0)<br></code></pre></td></tr></table></figure>
<p><strong>fruits 输出结果:</strong></p>
<blockquote>
<p>[“Banana”, “Orange”, “Banana”, “Orange”, “Apple”]</p>
</blockquote>
<p><strong>复制数组的前面两个元素到第三和第四个位置上：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;, &quot;Kiwi&quot;, &quot;Papaya&quot;];<br>fruits.copyWithin(2, 0, 2);<br></code></pre></td></tr></table></figure>
<p><strong>fruits 输出结果:</strong></p>
<blockquote>
<p>[“Banana”,”Orange”,”Banana”,”Orange”,”Kiwi”,”Papaya”]</p>
</blockquote>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p><strong><code>语法 : array.fill(value, start, end)</code></strong><br><code>value : 必需。填充的值</code><br><code>start : 可选。开始填充位置</code><br><code>end : 可选。停止填充位置 (默认为 array.length)</code><br><strong>使用一个固定值来填充数组</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;, &quot;pear&quot;];<br>fruits.fill(&quot;cantaloupe&quot;);<br></code></pre></td></tr></table></figure>
<p><strong>fruits 输出结果:</strong></p>
<blockquote>
<p>[“cantaloupe”, “cantaloupe”, “cantaloupe”, “cantaloupe”, “cantaloupe”]</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;, &quot;pear&quot;];<br>fruits.fill(&quot;cantaloupe&quot;, 2, 4);<br></code></pre></td></tr></table></figure>
<p><strong>fruits 输出结果:</strong></p>
<blockquote>
<p>[“Banana”, “Orange”, “cantaloupe”, “cantaloupe”, “pear”]</p>
</blockquote>
<h4 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h4><p><strong>删除数组的最后一个元素并返回删除的元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>console.log(fruits.pop())<br>console.log(fruits)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>Mango<br> [“Banana”, “Orange”, “Apple”]</p>
</blockquote>
<h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p><strong>删除数组的第一个元素并返回删除的元素</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>fruits.shift()<br>console.log(fruits)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p> [“Orange”, “Apple”, “Mango”]</p>
</blockquote>
<h4 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h4><p><strong>向数组的末尾添加一个或更多元素，并返回新的长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>fruits.push(&quot;Kiwi&quot;)<br>console.log(fruits)<br>fruits.push(&quot;Lemon&quot;,&quot;Pineapple&quot;)<br>console.log(fruits)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>[“Banana”, “Orange”, “Apple”, “Mango”, “Kiwi”]<br>[“Banana”, “Orange”, “Apple”, “Mango”, “Kiwi”, “Lemon”, “Pineapple”]</p>
</blockquote>
<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p><strong>向数组的开头添加一个或更多元素，并返回新的长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>fruits.unshift(&quot;Kiwi&quot;)<br>console.log(fruits)<br>fruits.unshift(&quot;Lemon&quot;,&quot;Pineapple&quot;)<br>console.log(fruits)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>[“Kiwi”, “Banana”, “Orange”, “Apple”, “Mango”]<br>[“Lemon”, “Pineapple”, “Kiwi”, “Banana”, “Orange”, “Apple”, “Mango”]</p>
</blockquote>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p><strong>反转数组的元素顺序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];<br>fruits.reverse();<br>console.log(fruits)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p> [“Mango”, “Apple”, “Orange”, “Banana”]</p>
</blockquote>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p><strong>对数组的元素进行排序</strong><br><strong>排序的方法比较的是 ASCLL，如果正常排序，此时 sort( ) 里面需要写一个匿名函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">arr.sort( function ( a, b )&#123;<br>    return;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p><strong>匿名函数注意事项:</strong></p>
<ol>
<li>必须写 2 形参</li>
<li>看返回值： 当返回值为<code>负数</code>时，那么前面的数放在前面, 当返回值为<code>正数</code>时，那么后面的数在前,为 <code>0 </code>时,不动</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 3, 2, 5, -1];<br>arr.sort();<br>console.log(arr)<br>var arr1 = [1, 3, 5, 4, 10];<br>arr1.sort(); //这里比较的是ASCLL<br>console.log(arr1)<br>arr1.sort(function (a, b) &#123;<br>    if (a &gt; b) &#123;<br>        return 1;<br>    &#125; else &#123;<br>        return -1;<br>    &#125;<br>&#125;);<br>console.log(arr1);<br></code></pre></td></tr></table></figure>
<p><strong>输出结果:</strong></p>
<blockquote>
<p>[-1, 1, 2, 3, 5]<br>[1, 10, 3, 4, 5]<br>[1, 3, 4, 5, 10]</p>
</blockquote>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p><strong>从数组中添加或删除元素</strong><br><strong><code>语法: array.splice(index,howmany,item1,.....,itemX)</code></strong><br><code>index : 从第几位开始</code><br><code>howmany : 截取多少长度</code><br><code>item1,.....,itemX : 在切口处添加新的数据</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 2, 3, 4, 5]<br>arr.splice(1, 2)<br>console.log(arr)<br>var arr1 = [1, 2, 3, 7, 8]<br>arr1.splice(3, 0, 4, 5, 6)<br>console.log(arr1)<br></code></pre></td></tr></table></figure>
<p><strong>输出结果 :</strong></p>
<blockquote>
<p>[1, 4, 5]<br>[1, 2, 3, 4, 5, 6, 7, 8]</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>js中遍历对象的几种方式</title>
    <url>/2023/03/13/js%E4%B8%AD%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这篇文章主要介绍了JS中5种遍历对象的方式<br>我们知道，在js的对象中，有下面几种属性:</p>
<ul>
<li>可枚举属性</li>
<li>不可枚举属性</li>
<li>从原型链上继承的属性</li>
<li>以Symbol作为key值</li>
</ul>
<h4 id="枚举是什么"><a href="#枚举是什么" class="headerlink" title="枚举是什么"></a>枚举是什么</h4><p>枚举是指对象中的属性是否可以遍历出来，再简单点说就是属性是否可以列举出来</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title>js中遍历数组的几种方式</title>
    <url>/2023/03/13/js%E4%B8%AD%E9%81%8D%E5%8E%86%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>JS数组遍历，基本就是for,for in,forEach,for of,map等等一些方法，以下介绍几种本文分析用到的数组遍历方式</p>
<h3 id="第一种-普通for循环"><a href="#第一种-普通for循环" class="headerlink" title="第一种: 普通for循环"></a>第一种: 普通for循环</h3><p>最简单的一种，也是使用频率最高的一种，虽然性能不弱，但仍有优化空间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;watermelon&quot;</span>, <span class="hljs-string">&quot;pear&quot;</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)         <span class="hljs-comment">// 0 1 2 3</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[i])    <span class="hljs-comment">// apple banana watermelon pear</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第二种-优化版for循环"><a href="#第二种-优化版for循环" class="headerlink" title="第二种: 优化版for循环"></a>第二种: 优化版for循环</h3><p>使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显<br>这种方法基本上是所有循环遍历方法中性能最高的一种</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];<br>for(let i = 0, len = arr.length; i &lt; len; i++) &#123;<br>  console.log(i)         // 0 1 2 3<br>  console.log(arr[i])    // apple banana watermelon pear<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第三种-弱化版for循环"><a href="#第三种-弱化版for循环" class="headerlink" title="第三种: 弱化版for循环"></a>第三种: 弱化版for循环</h3><p>这种方法其实严格上也属于for循环，只不过是没有使用length判断，而使用变量本身判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];<br>for (let i = 0; arr[i] != null; i++) &#123;<br>  console.log(i);        // 0 1 2 3<br>  console.log(arr[i]);   // apple banana watermelon pear<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第四种-forEach循环"><a href="#第四种-forEach循环" class="headerlink" title="第四种: forEach循环"></a>第四种: forEach循环</h3><p>数组自带的forEach循环，使用频率较高，实际上性能比普通for循环弱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];<br>arr.forEach((item, index, arr) =&gt; &#123;<br>  console.log(item);    // apple banana watermelon pear<br>  console.log(index);   // 0 1 2 3<br>  console.log(arr);     // 数组本身<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="第五种-forEach变种"><a href="#第五种-forEach变种" class="headerlink" title="第五种: forEach变种"></a>第五种: forEach变种</h3><p>由于forEach是Array型自带的，对于一些非这种类型的，无法直接使用(如NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有forEach功能。<br>实际性能要比普通forEach弱</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];<br>Array.prototype.forEach.call(arr, (item, index) =&gt; &#123;<br>  console.log(item);    // apple banana watermelon pear<br>  console.log(index);   // 0 1 2 3<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="第六种-for-in循环"><a href="#第六种-for-in循环" class="headerlink" title="第六种: for in循环"></a>第六种: for in循环</h3><p>这个循环很多人爱用，但实际上，经分析测试，在众多的循环遍历方式中它的效率是最低的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];<br>for (let i in arr) &#123;<br>  console.log(i);       // 0 1 2 3<br>  console.log(arr[i]);  // apple banana watermelon pear<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="第七种-map遍历"><a href="#第七种-map遍历" class="headerlink" title="第七种: map遍历"></a>第七种: map遍历</h3><p>这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上forEach</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];<br>arr.map((item, index) =&gt; &#123;<br>  console.log(item);    // apple banana watermelon pear<br>  console.log(index);   // 0 1 2 3<br>&#125;); <br></code></pre></td></tr></table></figure>
<h3 id="第八种-for-of遍历-需要ES6支持"><a href="#第八种-for-of遍历-需要ES6支持" class="headerlink" title="第八种: for of遍历(需要ES6支持)"></a>第八种: for of遍历(需要ES6支持)</h3><p>这种方式是es6里面用到的，性能要好于for in，但仍然比不上普通for循环</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;apple&quot;, &quot;banana&quot;, &quot;watermelon&quot;, &quot;pear&quot;];<br>for (let value of arr) &#123;<br>  console.log(value);  // apple banana watermelon pear<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="各种遍历方式的性能对比"><a href="#各种遍历方式的性能对比" class="headerlink" title="各种遍历方式的性能对比"></a>各种遍历方式的性能对比</h3><p>以下截图数据是，在chrome (支持es6)中运行了1000次后得出的结论(每次运行100次,一共10个循环，得到的分析结果) </p>
<div  align="center">    
<img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/6361fb0c77ece9ce732852ee1699d60.png" width = 100% height = 100% />
</div> 
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的浅拷贝与深拷贝</title>
    <url>/2023/03/13/JS%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E7%A5%9E%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用；<br>深拷贝是拷贝多层，每一级别的数据都会拷贝出来；<br><strong>总结来看 :</strong><br>浅拷贝的时候如果数据是基本数据类型，那么就如同直接赋值那种，会拷贝其本身，如果除了基本数据类型之外还有一层对象，那么对于浅拷贝而言就只能拷贝其引用，对象的改变会反应到拷贝对象上；但是深拷贝就会拷贝多层，即使是嵌套了对象，也会都拷贝出来。</p>
<h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><h4 id="实现方式一"><a href="#实现方式一" class="headerlink" title="实现方式一"></a>实现方式一</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var a = &#123;x : 1&#125;<br>var b = a<br>console.log(b)    // &#123;x:1&#125;<br>b.x = 2<br>console.log(a)   // &#123;x:2&#125;<br>console.log(b)   // &#123;x:2&#125;<br></code></pre></td></tr></table></figure>
<h4 id="实现方式二"><a href="#实现方式二" class="headerlink" title="实现方式二"></a>实现方式二</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var obj = &#123;<br>    name: &quot;abc&quot;,<br>    num: [1,2,3,4,5],<br>  &#125;<br>var obj1 = &#123;&#125;<br>for (var prop in obj) &#123;       //用遍历的方式将 obj 的数据拷贝给 obj1<br>    obj1[prop] = obj[prop]<br>&#125;<br>obj1.num[4] = 8<br>console.log(obj.num[4])    //此时可以看见 obj 的数据也进行了改变    8<br></code></pre></td></tr></table></figure>
<p><strong>上述案例可以看出:</strong> 浅拷贝是一个传址,也就是把 a 的值赋给 b 的时候同时也把 a 的址赋给了 b,当 a || b 的值改变的时候， a || b 的值也同时会改变, 实现浅拷贝的方法很多，这里不多讲，在来看看重点深拷贝</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="实现方式一-1"><a href="#实现方式一-1" class="headerlink" title="实现方式一"></a>实现方式一</h4><p><strong>使用递归复制所有层级属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function deepClone(obj) &#123;<br>  let objClone = Array.isArray(obj) ? [] : &#123;&#125;;<br>  if (obj &amp;&amp; typeof obj === &quot;object&quot;) &#123;<br>    for (let key in obj) &#123;<br>      if (obj.hasOwnProperty(key)) &#123;<br>        // 判断obj子元素是否为对象，如果是，递归复制<br>        if (obj[key] &amp;&amp; typeof obj[key] === &quot;object&quot;) &#123;<br>          objClone[key] = deepClone(obj[key]);<br>        &#125; else &#123;<br>          objClone[key] = obj[key];<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  return objClone;<br>&#125;<br>let a = [1, 2, 3, 4, [5, 6]];<br>let b = deepClone(a); <br>a[4][0] = 0;<br>console.log(a);  // [1, 2, 3, 4, [0, 6]]<br>console.log(b);  // [1, 2, 3, 4, [5, 6]]<br></code></pre></td></tr></table></figure>
<h4 id="实现方式二-1"><a href="#实现方式二-1" class="headerlink" title="实现方式二"></a>实现方式二</h4><p><strong>通过 JSON 对象实现深拷贝</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function deepClone (obj) &#123;<br>  let _obj = JSON.stringify(obj)<br>  let objClone = JSON.parse(_obj)<br>  return objClone<br>&#125;<br>let a = [0,1,[2,3],4]<br>let b = deepClone(a)<br>a[0] = 1  <br>a[2][0] = 1<br>console.log(a)  // [1,1,[1,3],4]<br>console.log(b)  // [0,1,[2,3],4]<br></code></pre></td></tr></table></figure>
<h4 id="实现方式三"><a href="#实现方式三" class="headerlink" title="实现方式三"></a>实现方式三</h4><p><strong>使用 JQ 的 extend 方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">$.extend([deep ], target, object1 [, objectN ])<br></code></pre></td></tr></table></figure>
<p>deep表示是否深拷贝，为true为深拷贝；为false，为浅拷贝。</p>
<p>target Object类型 目标对象，其他对象的成员属性将被附加到该对象上。</p>
<p>object1  objectN可选。 Object类型 第一个以及第N个被合并的对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let a = [0,1,[2,3],4]<br>let b = $.extend(true, [], a)<br>a[0] = 1<br>a[2][0] = 1<br>console.log(a)  // [1,1,[1,3],4]<br>console.log(b)  // [0,1,[2,3],4]<br></code></pre></td></tr></table></figure>
<p><strong>以上几种方法可完全实现深度拷贝，下面还有几种是不完全实现深度拷贝</strong></p>
<h3 id="浅深拷贝"><a href="#浅深拷贝" class="headerlink" title="浅深拷贝"></a>浅深拷贝</h3><p><strong>当对象中只有一级属性，没有二级属性的时候，此方法为深拷贝，但是对象中有对象的时候，此方法，在二级属性以后就是浅拷贝。</strong></p>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p><strong>使用扩展运算符实现深拷贝</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var obj = &#123; a: 1,b: &#123;c:2&#125;&#125;<br>var newObj = &#123; ...obj &#125;<br>obj.a = 2<br>obj.b.c = 0<br>console.log(obj);     // &#123; a: 2,b: &#123;c:0&#125;&#125;<br>console.log(newObj)   // &#123; a: 1,b: &#123;c:0&#125;&#125;<br></code></pre></td></tr></table></figure>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p><strong>数组中 slice 方法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let a = [0,1,[2,3],4]<br>let b = a.slice()<br>a[0] = 1<br>a[2][0] = 1<br>console.log(a)  // [1,1,[1,3],4]<br>console.log(b)  // [0,1,[1,3],4]<br></code></pre></td></tr></table></figure>
<p><strong>同理数组中的 concat 方法也会实现上述情况</strong></p>
<h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><p><strong>通过使用 Object.assign() 实现</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">const objA = &#123; a: 1, b: &#123; c: 2 &#125; &#125;;<br>const objB = &#123; name: &quot;xixi&quot; &#125;;<br>const obj = Object.assign(&#123;&#125;,objA, objB);<br>objA.a = 2;<br>objA.b.c = 3;<br>objB.name = &quot;haha&quot;;<br>console.log(objA);  //  &#123; a: 2, b: &#123; c: 3 &#125; &#125;;<br>console.log(objB);  //   &#123; name: &quot;haha&quot; &#125;;<br>console.log(obj);   // &#123; a: 1, b: &#123; c: 3 &#125;, name : &quot;xixi&quot; &#125;;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>浅拷贝</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown常用语法</title>
    <url>/2020/10/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br>Markdown具有一系列衍生版本，用于扩展Markdown的功能，这些功能原初的Markdown尚不具备，它们能让Markdown转换成更多的格式，例如LaTeX，Docbook。Markdown 语言在 2004 由约翰·格鲁伯（John Gruber）创建。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客等。<br>当前许多网站都使用了Markdown来撰写帮助文档或是用于论坛上发表消息。例如简书、知乎、CSDN、GitHub、OpenStreetMap 、Diaspora等。  </p>
<h2 id="Markdown基础语法"><a href="#Markdown基础语法" class="headerlink" title="Markdown基础语法"></a>Markdown基础语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>在想要设置为标题的文字前面加#来表示<br>一个#是一级标题，两个#是二级标题，以此类推。支持六级标题，标题字号逐级递减降低<br><strong>注意：语法在#后跟个空格再写文字</strong><br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure>
<p><strong>效果如下:</strong>  </p>
<div align=center>
<img src="https://img-blog.csdnimg.cn/20200426182643977.png?" width = 50% height = 50%>
</div>

<h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h3><p>斜体<br>要倾斜的文字左右分别用一个 * 号包起来<br>加粗<br>要加粗的文字左右分别用两个 * 号包起来<br>斜体加粗<br>要倾斜和加粗的文字左右分别用三个 * 号包起来<br>删除线<br>要加删除线的文字左右分别用两个~~号包起来<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">*这是倾斜的文字*<br>**这是加粗的文字**<br>***这是斜体加粗的文字***<br>~~这是加删除线的文字~~<br></code></pre></td></tr></table></figure>
<p><strong>效果如下:</strong><br><em>这是倾斜的文字</em><br><strong>这是加粗的文字</strong><br><em><strong>这是斜体加粗的文字</strong></em><br><del>这是加删除线的文字</del>  </p>
<h3 id="3-分割线"><a href="#3-分割线" class="headerlink" title="3. 分割线"></a>3. 分割线</h3><p>三个 - 或者 *<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">---<br>***<br></code></pre></td></tr></table></figure>
<p><strong>效果如下:</strong></p>
<hr>
<hr>
<h3 id="4-引用"><a href="#4-引用" class="headerlink" title="4. 引用"></a>4. 引用</h3><p>在需要引用的文字前加 &gt;<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&gt;大家好，你们好<br></code></pre></td></tr></table></figure>
<p><strong>效果如下:</strong></p>
<blockquote>
<p>大家好，你们好</p>
</blockquote>
<h3 id="5-图片"><a href="#5-图片" class="headerlink" title="5. 图片"></a>5. 图片</h3><p>![图片下方显示名字](“图片url 鼠标放在图片上的显示信息”)<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">![我是皮卡丘](https://img-blog.csdnimg.cn/20200507103002365.png &quot;皮卡皮卡&quot;)<br></code></pre></td></tr></table></figure>
<p><strong>效果如下:</strong></p>
<div align=center>

<p><img  src="https://img-blog.csdnimg.cn/20200507103002365.png"   title="皮卡皮卡"><span class="image-caption">我是皮卡丘</span></p>
</div>

<h3 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6. 超链接"></a>6. 超链接</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[网址名](网址) <br></code></pre></td></tr></table></figure>
<p><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">[GitHub](https://github.com/)<br>[百度](https://www.baidu.com/) <br></code></pre></td></tr></table></figure>
<p><a href="https://github.com/">GitHub</a><br><a href="https://www.baidu.com/">百度</a> </p>
<h3 id="7-列表"><a href="#7-列表" class="headerlink" title="7. 列表"></a>7. 列表</h3><p><strong>有序列表:</strong><br>数字加上 . (后面跟上一个空格)<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">1. 有序列表<br>2. 有序列表<br>3. 有序列表<br></code></pre></td></tr></table></figure>
<ol>
<li>有序列表</li>
<li>有序列表</li>
<li>有序列表</li>
</ol>
<p><strong>无序列表:</strong><br>内容前面加上 *，+，- (后面跟上一个空格)<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">* 无序列表<br>+ 无序列表<br>- 无序列表<br></code></pre></td></tr></table></figure>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<h3 id="8-代码插入"><a href="#8-代码插入" class="headerlink" title="8. 代码插入"></a>8. 代码插入</h3><p>单行代码:<br>用两个`把代码内容包起来<br>‘包裹的代码’<br><strong>示列:</strong></p>
<p><code>Hello World</code></p>
<p>代码块:<br>用 两个```把代码块包起来<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var num =(function(a, b ,c)&#123;<br>    var d = a + b + c + 1;  <br>    return d<br>&#125;(1,2,3))<br></code></pre></td></tr></table></figure>
<h2 id="Markdown进阶"><a href="#Markdown进阶" class="headerlink" title="Markdown进阶"></a>Markdown进阶</h2><h3 id="1-文字缩进"><a href="#1-文字缩进" class="headerlink" title="1. 文字缩进"></a>1. 文字缩进</h3><p>在要缩进的文字前使用 <code>&amp;emsp;</code>(注意后面要加上空格)<br><strong>示列:</strong><br>我是缩进前的文字<br>&emsp; &emsp; &emsp; 我是缩进后的文字</p>
<h3 id="2-文字居中"><a href="#2-文字居中" class="headerlink" title="2. 文字居中"></a>2. 文字居中</h3><p>对于标准的markdown文本，是不支持居中对齐的。但是markdown支持html语言，所以可以采用html语法格式来实现<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;center&gt;我要居中显示&lt;/center&gt;<br></code></pre></td></tr></table></figure>
<center>我要居中显示</center>

<h3 id="3-字体字号及颜色"><a href="#3-字体字号及颜色" class="headerlink" title="3. 字体字号及颜色"></a>3. 字体字号及颜色</h3><p>同样采用HTML语法实现<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;center&gt;&lt;font face=&quot;微软雅黑&quot; size=8 color=red&gt;我是一行文本&lt;/font&gt;&lt;/center&gt;<br></code></pre></td></tr></table></figure>
<center><font face="微软雅黑" size=8 color=red>我是一行文本</font></center>

<h3 id="4-图片的大小和位置"><a href="#4-图片的大小和位置" class="headerlink" title="4. 图片的大小和位置"></a>4. 图片的大小和位置</h3><p>center 居中 ，center换成 left 和 right 可以实现居左，居右<br>width 和 height 调控宽度和高度<br><strong>示列:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;div  align=&quot;center&quot;&gt;    <br>&lt;img src=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3222272914,986927614&amp;fm=26&amp;gp=0.jpg&quot; width = 50% height = 50% /&gt;<br>&lt;/div&gt;  <br></code></pre></td></tr></table></figure>
<div  align="center">    
<img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3222272914,986927614&fm=26&gp=0.jpg" width = 50% height = 50% />
</div>  

<h2 id="Markdown更多用法"><a href="#Markdown更多用法" class="headerlink" title="Markdown更多用法"></a>Markdown更多用法</h2><p><a href="https://markdown-zh.readthedocs.io/">Markdown 中文文档</a></p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>npm初始化或安装模块报错</title>
    <url>/2023/03/13/npm%E5%88%9D%E5%A7%8B%E5%8C%96%E6%88%96%E5%AE%89%E8%A3%85%E6%A8%A1%E5%9D%97%E6%97%B6%EF%BC%8C%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>报错信息如图:</p>
<div>    
<img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/微信截图_20210718201153.png" width = 100% height = 100% />
</div> 

<p>网上有说是版本不一致的原因，那么检测 npm 的版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm -v<br>更新npm版本命令:<br>npm install npm -g 要记住全局更新<br>cnpm install npm -g 淘宝镜像会比较快<br></code></pre></td></tr></table></figure>
<p>安装完之后查看npm -v，还是之前的版本，说明本地已经是最新版本了。不是版本原因<br>清除npm的缓存 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm cache clean --force<br></code></pre></td></tr></table></figure>
<p>然后再运行我们需要安装模块的命令<br>有时是网络问题，依赖包加载不完整，删掉node_modules文件后，重新执行 <code>npm install</code>即可</p>
]]></content>
      <categories>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>React中props与state的区别</title>
    <url>/2020/10/27/props%E4%B8%8Estate%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><p>主要是用于组件之间传递参数，获取组件的属性值。 组件之间数据单向流动 ，从父组件流向子组件。属性值是无法修改的，它是只读的。</p>
<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>React组件的核心，是数据的来源，主要用于组件更新控制。如果想重新渲染或更新组件，只需要修改<code>state</code>即可，然后根据具体修改的<code>state</code>,重新渲染用户界面（无需操作DOM对象），可以通过<code>this.state</code>来访问它们</p>
<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p>在React中，如果想更新<code>state</code>里面的值，必须使用<code>this.setState( )</code>方法,从而更新组件的状态，这是一个异步方法，而且有第二个参数，是一个回调函数</p>
<p><strong>代码示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>// 父组件<br>class Father extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>      // 初始化数据<br>      name: &quot;鸣人&quot;<br>    &#125;<br>  &#125;;<br>  componentDidMount() &#123;<br>    //修改 name 值<br>    this.setState(&#123; name: &quot;佐助&quot; &#125;, () =&gt; &#123; //第二个参数：回调函数<br>      //输出 佐助<br>      console.log(this.state.name)<br>    &#125;)<br>    // 输出 鸣人    name值已经修改，但输出的是鸣人，原因是setState是一个异步方法  <br>    console.log(this.state.name)<br>  &#125;<br>  render() &#123;<br>    const &#123; name &#125; = this.state<br>    return (<br>      &lt;React.Fragment&gt;<br>        &#123;/* 传递 name 参数 */&#125;<br>        &lt;Son myName=&#123;name&#125;&gt;&lt;/Son&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>// 子组件<br>class Son extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;&#125;<br>  &#125;<br>  render() &#123;<br>    const &#123; myName &#125; = this.props<br>    return (<br>      &lt;React.Fragment&gt;<br>        &#123;/* 通过 this.props获取属性值 */&#125;<br>        &lt;h4&gt;我的名字: &#123;myName&#125;&lt;/h4&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br><br>  &#125;<br>&#125;<br>export default Father;<br><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>props</tag>
        <tag>state</tag>
      </tags>
  </entry>
  <entry>
    <title>React redux的使用</title>
    <url>/2020/11/08/React%20redux%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redux 是 JavaScript 状态容器，提供可预测化得状态管理，可以跨组件、跨页面推送数据。应用场景如 : 购物车、会员登录等功能模块。Redux 由 Flux 演变而来<br><strong>存储流程:</strong><br>Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中，store 是简单的 JavaScript 对象，而改变应用的 start 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers来修改 state。整个 state 转化是在 reducers 中完成  </p>
<p><strong>流程可分为4大部:</strong><br><strong>1. 选购商品</strong><br><strong>2. 商品装车</strong><br><strong>3. 存入仓库</strong><br><strong>4. 从仓库获取商品</strong></p>
<h2 id="安装-redux"><a href="#安装-redux" class="headerlink" title="安装 redux"></a>安装 redux</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install redux --save<br>npm install react-redux --save<br></code></pre></td></tr></table></figure>
<p><font size=5>计数器案例:</font></p>
<p>在 src 新建一个 store 文件, 再次文件下分别建立 actions reducers 文件<br>子组件 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class Couter extends React.Component &#123;<br>    render() &#123;<br>        return(<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;<br>                    子组件计数器 : 0<br>                &lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default Couter;<br></code></pre></td></tr></table></figure>
<h2 id="选购商品"><a href="#选购商品" class="headerlink" title="选购商品"></a>选购商品</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;<br>// 关联仓库，将组件进行包裹起来，此时该组件就有 redux 的属性<br>import &#123;connect&#125; from &#x27;react-redux&#x27;<br>import Conter from &quot;../../components/counter&quot;<br>import actions from &#x27;../../store/actions&#x27;;<br>class IndexPage extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.num = 0 <br>    &#125;<br>    inCount() &#123;     //  点击 ++<br>        // 1. 选购商品 this.props.dispatch<br>        //  使用 dispatch 属性触发 actions，  其中 type 为必填项,其他的属性可以自行添加 <br>        //  this.props.dispatch(&#123;type: &quot;INC&quot;, data: &#123;count: ++this.num&#125;&#125;)   //正常写法,推荐使用下面采取模块化<br>        // 调用 actions.counter.incCount 方法 并传递数据<br>        this.props.dispatch(actions.counter.incCount(&#123;count: ++this.num&#125;))<br>    &#125;<br>    deCount() &#123;      //点击 -- <br>        this.props.dispatch(actions.counter.decCount(&#123;count: --this.num&#125;))<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &#123;/* 子组件 */&#125;<br>                &lt;Conter /&gt;<br>                &lt;div&gt; <br>                    计数器 : &lt;button type=&quot;button&quot; onClick=&#123;this.deCount.bind(this)&#125;&gt;-&lt;/button&gt; 0 &lt;button onClick=&#123;this.inCount.bind(this)&#125;&gt;+&lt;/button&gt;<br>                &lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default connect()(IndexPage);<br></code></pre></td></tr></table></figure>
<p><strong>actions 文件下建立 index.js  和 counter.js</strong><br><strong>counter.js文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export function incCount(data) &#123;<br>    return &#123;<br>        type: &quot;INC&quot;,<br>        data   // data:data<br>    &#125;<br>&#125;<br>export function decCount(data) &#123;<br>    return &#123;<br>        type: &quot;DEC&quot;,<br>        data<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>index.js文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// import &#123;decCount, decCount&#125; from &#x27;./couter&#x27; 导入 decCount decCount方法<br>import * as counter from &#x27;./counter&#x27;    //导入 counter文件中所有的方法<br>export default &#123;<br>    counter,    //counter: counter<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="商品装车"><a href="#商品装车" class="headerlink" title="商品装车"></a>商品装车</h2><p><strong>reducers 文件下建立 counter.js</strong><br><strong>counter.js文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//2. 商品装车<br>let defaultState = &#123; <br>  count: 0<br>&#125;<br>// state : 数据源       action : 获取 dispatch 的值<br>function counterReducer(state = defaultState, action) &#123;<br>  switch (action.type) &#123;<br>    case &quot;INC&quot;:<br>      return &#123; ...state, ...action.data &#125;;              //写法一  常用<br>    case &quot;DEC&quot;:<br>      return Object.assign(&#123;&#125;, state, action.data)      //写法二<br>    default:<br>      return state;    //必须的返回 state， 否则会出错<br>  &#125;<br>&#125;<br>export default counterReducer;<br></code></pre></td></tr></table></figure>
<h2 id="存入仓库"><a href="#存入仓库" class="headerlink" title="存入仓库"></a>存入仓库</h2><p><strong>reducers 文件下建立 index.js</strong><br><strong>index.js文件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// 引入 createStore 仓库，为 store 的创建做准备  combineReducers用于组合关联使用<br>import &#123; createStore, combineReducers &#125; from &#x27;redux&#x27;;<br>import CounterReducer from &#x27;./counter&#x27;;<br>// 3.创建仓库， 将reducers存储到仓库(存放数据)<br>// let store = createStore(CounterReducer)   传入单个方法<br>let store = createStore(combineReducers(&#123;   //传入多个个方法<br>    counter: CounterReducer,<br>  &#125;))<br>  export default store;<br></code></pre></td></tr></table></figure>
<p><strong>在入口index中添加 store</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import ReactDOM from &#x27;react-dom&#x27;;<br>import RouterComponent from &#x27;./router&#x27;;<br>// 用于读取数据 <br>import &#123; Provider &#125; from &#x27;react-redux&#x27;<br>import store from &#x27;./store/reducers&#x27;<br>import * as serviceWorker from &#x27;./serviceWorker&#x27;;<br>function App() &#123;<br>  return (<br>    &lt;React.Fragment&gt;<br>      &#123;/* 使用 Provider, 添加上 store 属性*/&#125;<br>      &lt;Provider store=&#123;store&#125;&gt;<br>        &lt;RouterComponent /&gt;<br>      &lt;/Provider&gt;<br>    &lt;/React.Fragment&gt;<br>  )<br>&#125;<br>ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));<br>// If you want your app to work offline and load faster, you can change<br>// unregister() to register() below. Note this comes with some pitfalls.<br>// Learn more about service workers: https://bit.ly/CRA-PWA<br>serviceWorker.unregister();<br><br></code></pre></td></tr></table></figure>
<h2 id="从仓库获取商品"><a href="#从仓库获取商品" class="headerlink" title="从仓库获取商品"></a>从仓库获取商品</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;<br>// 关联仓库，将组件进行包裹起来，此时该组件就有 redux 的属性<br>import &#123;connect&#125; from &#x27;react-redux&#x27;<br>import Conter from &quot;../../components/counter&quot;<br>import actions from &#x27;../../store/actions&#x27;;<br>class IndexPage extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.num = 0 <br>    &#125;<br>    inCount() &#123;     //  点击 ++<br>        this.props.dispatch(actions.counter.incCount(&#123;count: ++this.num&#125;))<br>    &#125;<br>    deCount() &#123;      //点击 -- <br>        this.props.dispatch(actions.counter.decCount(&#123;count: --this.num&#125;))<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &#123;/* 子组件 */&#125;<br>                &lt;Conter /&gt;<br>                &lt;div&gt; <br>                    &#123;/* 4. 从仓库获取商品 */&#125;<br>                    计数器 : &lt;button type=&quot;button&quot; onClick=&#123;this.deCount.bind(this)&#125;&gt;-&lt;/button&gt;  &#123;this.props.state.counter.count&#125; &lt;button onClick=&#123;this.inCount.bind(this)&#125;&gt;+&lt;/button&gt;<br>                &lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default connect((state) =&gt;&#123;  //  state 接收第二步中的 state<br>    return &#123;<br>        state : state<br>    &#125;<br>&#125;)(IndexPage);<br></code></pre></td></tr></table></figure>
<p>子组件 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123;connect&#125; from &#x27;react-redux&#x27;<br>class Couter extends React.Component &#123;<br>    render() &#123;<br>        const &#123;count&#125; = this.props<br>        return(<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;<br>                    子组件计数器 : &#123;count&#125;<br>                &lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>//只有和仓关联起来，才可访问 redux 的属性<br>export default connect((state) =&gt;(&#123;<br>    count:state.counter.count<br>&#125;))(Couter);<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>redux</tag>
      </tags>
  </entry>
  <entry>
    <title>React实现数据双向绑定</title>
    <url>/2023/03/13/React%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>双向数据绑定，带来双向数据流。数据（state）和视图（View）之间的双向绑定。<br>说到底就是 （value 的单向绑定 + onChange 事件侦听）的一个语法糖<br><strong>特点:</strong> 无论数据改变，或是用户操作，都能带来互相的变动，自动更新。适用于项目细节</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            amount: 0<br>        &#125;<br>    &#125;<br>    changeAmout(e) &#123;<br>        this.setState(&#123; amount: e.target.value &#125;)<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;div&gt;<br>                数量 ：&lt;input type=&quot;text&quot; value=&#123;this.state.amount&#125; onChange=&#123;(event)=&gt;&#123;<br>                    this.changeAmout(event)<br>                &#125;&#125;/&gt;<br>                &lt;br/&gt;<br>                数量值 : &#123;this.state.amount&#125;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>双向绑定</tag>
      </tags>
  </entry>
  <entry>
    <title>React入门基础</title>
    <url>/2020/10/26/React%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>它是一个将数据渲染为 HTML 视图 的 js 库</p>
<h4 id="原生-js-痛点"><a href="#原生-js-痛点" class="headerlink" title="原生 js 痛点"></a>原生 js 痛点</h4><p>用 dom 的 API 去操作 dom，繁琐且效率低<br>用 js 直接操作 dom，浏览器会进行大量的回流和重绘<br>原生 js 没有组件化的编程方案，代码复用性低,对样式和结构也没办法拆解</p>
<h4 id="React-特点"><a href="#React-特点" class="headerlink" title="React 特点"></a>React 特点</h4><p>采用组件化模式，声明式编码，提高开发效率和组件复用性<br>在 React Native 中可以用 react 预发进行安卓、ios 移动端开发<br>使用虚拟 dom 和有些的 diffing 算法，尽量减少与真实 dom 的交互，提高性能</p>
<h3 id="模块与组件、模块化与组件化"><a href="#模块与组件、模块化与组件化" class="headerlink" title="模块与组件、模块化与组件化"></a>模块与组件、模块化与组件化</h3><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><ol>
<li>一般就是指 js 文件</li>
<li>为什么要拆成模块： 随着业务逻辑的增加，代码越来越复杂</li>
<li>作用： 复用 js，简化 js 的编写，提高 js 的工作效率</li>
</ol>
<h4 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h4><ol>
<li>用来实现局部功能效果的代码和资源的集合</li>
<li>为什么使用组件： 因为一个界面的功能很复杂，需要拆分</li>
<li>作用： 复用编码，简化项目编码，提高运行效率</li>
</ol>
<h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p>当应用的 js 都是已模块的方式来编写的时候，那么这个应用就是模块化的应用</p>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><p>当应用是已多组件的方式实现的，那么这个应用就是组件化的应用</p>
<h3 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h3><p>React 通过组件的思想，将界面拆分成一个个可复用的模块，每一个模块就是一个 React 组件。一个 React 应用由若干组件组合而成，一个复杂组件也可以由若干简单组件组合而成</p>
<h4 id="创建组件方式"><a href="#创建组件方式" class="headerlink" title="创建组件方式"></a>创建组件方式</h4><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数<br>定义组件的两个要求:</p>
<ol>
<li>组件名称必须以大写字母开头</li>
<li>组件的返回值只能有一个根元素</li>
</ol>
<h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><ol>
<li>就是一个函数</li>
<li>没有生命周期函数</li>
<li>不能使用 state,只会接收一个 props 形参,并且直接使用 props 参数不需要 this</li>
<li>无状态组件就是一个简单的视图函数，没有业务逻辑更纯粹的展示 UI</li>
</ol>
<p><strong>代码示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Welcome() &#123;<br>  console.log(this)    // undefined<br>  // bable 中开启严格模式<br>  return (<br>    &lt;div&gt;无状态组件 ( 适用于 简单 组件的定义 无state  状态 ）)&lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h4><ol>
<li>是一个 class 类，继承了类的组件是类式组件,继承自 React.Component 类</li>
<li>类式组件必须拥有继承 extends React.Component 和 render 属性</li>
<li>可以使用 state 和 props,并且都是使用 this 来调用 this.state 或 this.props</li>
<li>拥有生命周期函数</li>
<li>类式组件可以使用生命周期可以在里面写业务逻辑，可以在里面做任何事情</li>
</ol>
<p><strong>代码示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">class Welcome extends React.Component &#123;<br>  render() &#123;<br>    console.log(this)    // Welcome组件的实例对象<br>    return (<br>      &lt;div&gt;类式组件 ( 适用于 复杂 组件的定义 有state（ 状态 ）)&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h3><ol>
<li>通过 onXxxx 属性指定事件处理函数（小驼峰形式）</li>
<li>通过 event.target 可以得到发生事件的 Dom 元素</li>
<li>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串</li>
</ol>
<h3 id="组件的三大属性"><a href="#组件的三大属性" class="headerlink" title="组件的三大属性"></a>组件的三大属性</h3><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><ol>
<li>state 是组件实例对象最重要的属性，必须是对象的形式</li>
<li>组件被称为状态机，通过更改 state 的值来达到更新页面显示（重新渲染组件）</li>
<li>组件 render 中的 this 指的是组件实例对象</li>
<li>状态数据不能直接赋值，需要用 setState（）</li>
<li>组件自定义方法中的 this 为 undefined, 怎么解决？<br>将自定义函数改为表达式+箭头函数的形式（推荐）<br>在构造器中用 bind（）强制绑定 this</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment &#125; from &quot;react&quot;;<br>class Welcome extends React.Component &#123;<br>  constructor(props) &#123;<br>    // constructor 调用次数 1   页面初始化<br>    super(props);<br>    this.state = &#123;<br>      isHot: false,<br>    &#125;;<br>  &#125;<br>  change() &#123;<br>    // 状态的 (state) 不可直接修改，必须痛过 this.setState 方法<br>    this.setState(&#123; isHot: !this.state.isHot &#125;);<br>  &#125;<br>  render() &#123;<br>    // render调用次数  1 + n    1: 页面初始化执行   n: 状态更新次数<br>    const &#123;<br>      state: &#123; isHot &#125;,<br>      change,<br>    &#125; = this;<br>    return (<br>      &lt;Fragment&gt;<br>        &lt;div onClick=&#123;change.bind(this)&#125;&gt;<br>          今天的天气&#123;isHot ? &quot;凉爽&quot; : &quot;炎热&quot;&#125;<br>        &lt;/div&gt;<br>      &lt;/Fragment&gt;<br>    );<br>  &#125;<br>&#125;<br>export default Welcome;<br></code></pre></td></tr></table></figure>

<p>精简版：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment &#125; from &quot;react&quot;;<br>class Welcome extends React.Component &#123;<br>  state = &#123;<br>    isHot: false,<br>    num: 0,<br>  &#125;;<br><br>  change = () =&gt; &#123;<br>    //结果还是之前的，而不是+1之后的<br>    // this.setState是异步的  在你调用了this.setState后在他的下面输出他的结果还是没变的状态<br>    this.setState(&#123; isHot: !this.state.isHot, num: this.state.num + 1 &#125;);<br>    console.log(this.state.num, &quot;执行1&quot;);<br>  &#125;;<br><br>  addNum = () =&gt; &#123;<br>    this.setState((data) =&gt; &#123;<br>      // this.setState的第一个参数可以是一个对象，也可以是一个函数返回一个对象，函数的参数是上一次的state<br>      console.log(data);<br>      return &#123; num: data.num + 1 &#125;;<br>    &#125;);<br>  &#125;;<br><br>  reduce = () =&gt; &#123;<br>    //this.setState的第二个参数是它的回调函数，在前面重新给state赋值后执行<br>    this.setState(&#123; num: this.state.num - 1 &#125;, () =&gt; &#123;<br>      console.log(this.state.num);<br>    &#125;);<br>  &#125;;<br><br>  render() &#123;<br>    console.log(this.state.num, &quot;执行2&quot;);<br>    const &#123;<br>      state: &#123; isHot &#125;,<br>      change,<br>      addNum,<br>      reduce,<br>    &#125; = this;<br>    return (<br>      &lt;Fragment&gt;<br>        &lt;div onClick=&#123;change&#125;&gt;今天的天气&#123;isHot ? &quot;凉爽&quot; : &quot;炎热&quot;&#125;&lt;/div&gt;<br>        &lt;button onClick=&#123;addNum&#125;&gt;加➕&lt;/button&gt;<br>        &lt;button onClick=&#123;reduce&#125;&gt;减➖&lt;/button&gt;<br>      &lt;/Fragment&gt;<br>    );<br>  &#125;<br>&#125;<br>export default Welcome;<br></code></pre></td></tr></table></figure>

<h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>props 就是在调用组件的时候在组件中添加属性传到组件内部去使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment &#125; from &quot;react&quot;;<br>import PropTypes from &quot;prop-types&quot;;<br>class Person extends React.Component &#123;<br>  // 类型检测<br>  static propTypes = &#123;<br>    // array : 数组类型<br>    // bool : 布尔类型<br>    // func : 函数<br>    // number : 数字<br>    // object : 对象<br>    // string : 字符串<br>    // symbol : ES6新增的symbol类型<br><br>    name: PropTypes.string.isRequired, // 必须传递字符串类型<br>    sex: PropTypes.string, // 字符串类型<br>    age: PropTypes.number, // 字符串类型<br>  &#125;;<br><br>  // 默认值<br>  static defaultProps = &#123;<br>    sex: &quot;女&quot;,<br>    age: 18,<br>  &#125;;<br><br>  render() &#123;<br>    // props 是只读的，不可修改<br>    const &#123; name, age, sex &#125; = this.props;<br>    return (<br>      &lt;Fragment&gt;<br>        &lt;div&gt;姓名: &#123;name&#125;&lt;/div&gt;<br>        &lt;div&gt;年龄: &#123;age&#125;&lt;/div&gt;<br>        &lt;div&gt;性别: &#123;sex&#125;&lt;/div&gt;<br>      &lt;/Fragment&gt;<br>    );<br>  &#125;<br>&#125;<br>class Welcome extends React.Component &#123;<br>  render() &#123;<br>    const a = &#123; name: &quot;猪猪&quot; &#125;;<br>    const b = &#123; name: &quot;粥粥&quot;, age: 23, sex: &quot;男&quot; &#125;;<br>    return (<br>      &lt;Fragment&gt;<br>        &lt;Person &#123;...a&#125; /&gt;<br>        &lt;Person &#123;...b&#125; /&gt;<br>      &lt;/Fragment&gt;<br>    );<br>  &#125;<br>&#125;<br>export default Welcome;<br><br></code></pre></td></tr></table></figure>

<h4 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h4><p>refs 是组件实例对象中的属性，它专门用来收集那些打了 ref 标签的 dom 元 素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment, createRef &#125; from &quot;react&quot;;<br>class Welcome extends React.Component &#123;<br>  myRef = createRef();<br><br>  showData = () =&gt; &#123;<br>    // 不推荐使用 字符串 形的 ref, (效率不高)<br>    const &#123; input1 &#125; = this.refs;<br>    alert(input1.value);<br>  &#125;;<br><br>  showData2 = () =&gt; &#123;<br>    // 回调形式的 ref<br>    // 如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行两次，第一次传入参数 null，然后第二次会传入参数 DOM 元素<br>    const &#123; input2 &#125; = this;<br>    alert(input2.value);<br>  &#125;;<br><br>  showData3 = () =&gt; &#123;<br>    // React.createRef   （推荐使用）<br>    // 调用后可以返回一个容器，该容器可以存储被 ref 所表标识的节点， 该容器是 “专人专用” 的<br>    const &#123; value &#125; = this.myRef.current;<br>    alert(value);<br>  &#125;;<br><br>  render() &#123;<br>    const &#123; showData, showData2, myRef, showData3 &#125; = this;<br>    return (<br>      &lt;Fragment&gt;<br>        &lt;input ref=&quot;input1&quot; placeholder=&quot;点击按钮提示&quot; /&gt; &amp;nbsp;<br>        &lt;button onClick=&#123;showData&#125;&gt;点击提示&lt;/button&gt;&amp;nbsp;<br>        &lt;input<br>          ref=&#123;(current) =&gt; (this.input2 = current)&#125;<br>          onBlur=&#123;showData2&#125;<br>          placeholder=&quot;失去焦点提示&quot;<br>        /&gt;<br>        &amp;nbsp;<br>        &lt;input ref=&#123;myRef&#125; onBlur=&#123;showData3&#125; placeholder=&quot;失去焦点提示&quot; /&gt;<br>      &lt;/Fragment&gt;<br>    );<br>  &#125;<br>&#125;<br>export default Welcome;<br><br></code></pre></td></tr></table></figure>

<h3 id="高阶函数和函数柯里化"><a href="#高阶函数和函数柯里化" class="headerlink" title="高阶函数和函数柯里化"></a>高阶函数和函数柯里化</h3><p>高阶函数：如果一个函数符合下面的 2 个规范的任何一个，那么改函数就是高阶函数</p>
<ol>
<li>若 A 函数，接受的参数是一个函数，那么 A 就是高阶函数</li>
<li>若 A 函数， 调用的返回值依然是一个函数，那么 A 就是高阶函数<br>常见的高阶函数： Promise map setTimeOut</li>
</ol>
<p>函数柯里化：通过函数的回调继续返回函数的方式， 实现多次接受函数最后统一处理的函数编码形式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment &#125; from &quot;react&quot;;<br>class Welcome extends React.Component &#123;<br>  state = &#123;<br>    name: &quot;&quot;,<br>    age: &quot;&quot;,<br>  &#125;;<br>  save = (type) =&gt; &#123;<br>    return (e) =&gt; this.setState(&#123; [type]: e.target.value &#125;);<br>  &#125;;<br>  render() &#123;<br>    return (<br>      &lt;Fragment&gt;<br>        &lt;input onChange=&#123;this.save(&quot;name&quot;)&#125; /&gt; &amp;nbsp;<br>        &lt;input onChange=&#123;this.save(&quot;age&quot;)&#125; /&gt;<br>      &lt;/Fragment&gt;<br>    );<br>  &#125;<br>&#125;<br>export default Welcome;<br><br></code></pre></td></tr></table></figure>

<h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p><strong>旧的生命周期 和 新的生命周期区别</strong><br><strong>旧的生命周期</strong>即将废弃 3 个勾子函数:<br>componentWillMount<br>componentWillReceiveProps<br>componentWillUpdate<br><strong>新的生命周期</strong>新增 2 个勾子函数<br>getDerivedStateFromProps<br>getSnapshotBeforeUpdate</p>
<h4 id="旧版本生命周期"><a href="#旧版本生命周期" class="headerlink" title="旧版本生命周期"></a>旧版本生命周期</h4><div  align="center">    
<img src="https://gitee.com/zuo_jiahui/blogimage/raw/b4f9f5540825aef435c0f17c818738cfcb22a8cb/img/20211209095419.png" width = 100% height = 100 />
</div>

<p><strong>生命周期的三个阶段</strong></p>
<ol>
<li>初始化阶段：由 ReactDom.render () 触发 - - - 初次渲染<br>constructor ()<br>componentWillMount ()<br>render ()<br><strong>componentDidMount () 常用</strong></li>
<li>更新阶段：由组件内部的 this.setState () 或 render () 触发<br>componentWillReceiveProps ()<br>shouldComponentUpdate ()<br>componentWillUpdate ()<br><strong>render () 必用</strong><br>componentDidUpdate ()</li>
<li>卸载阶段： 由 ReactDom.unmountComponentAtNode () 触发<br><strong>componentWillUnmount () 常用</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment &#125; from &quot;react&quot;;<br>import ReactDOM from &quot;react-dom&quot;;<br>class Demo extends React.Component &#123;<br>  componentWillReceiveProps(props) &#123;<br>    console.log(props);<br>  &#125;<br>  render() &#123;<br>    return &lt;div&gt;&#123;this.props.conut&#125;&lt;/div&gt;;<br>  &#125;<br>&#125;<br>class Welcome extends React.Component &#123;<br>  // 挂载 constructor  componentWillMount  render  componentDidMount<br>  // 构造器<br>  constructor(prpos) &#123;<br>    console.log(&quot;第 1 执行&quot;);<br>    super(prpos);<br>    this.state = &#123;<br>      conut: 0,<br>      num: 1,<br>    &#125;;<br>    this.num = 1;<br>  &#125;<br>  // 组件挂将要挂在<br>  componentWillMount() &#123;<br>    console.log(&quot;第 2 执行&quot;);<br>  &#125;<br>  // 组件挂在完毕<br>  componentDidMount() &#123;<br>    console.log(&quot;第 4 执行&quot;);<br>  &#125;<br><br>  // 组件更新 componentWillReceiveProps shouldComponentUpdate render componentWillUpdate componentDidUpdate<br>  // 控制组件是否被更新<br>  shouldComponentUpdate() &#123;<br>    console.log(&quot;更新 1 执行&quot;);<br>    const &#123; conut &#125; = this.state;<br>    if (conut &gt; 3) &#123;<br>      return false;<br>    &#125;<br>    return true;<br>  &#125;<br>  // 组件将要更新<br>  componentWillUpdate() &#123;<br>    console.log(&quot;更新 2 执行&quot;);<br>  &#125;<br>  // 组件更新完毕<br>  componentDidUpdate() &#123;<br>    console.log(&quot;更新 4 执行&quot;);<br>  &#125;<br>  // 组件将要卸载执行<br>  componentWillUnmount() &#123;<br>    console.log(&quot;卸载 1 执行&quot;);<br>  &#125;<br>  // 初始渲染 状态更新 执行<br>  render() &#123;<br>    console.log(&quot;第 3 执行&quot;, &quot;更新 3 执行&quot;);<br>    const &#123;<br>      state: &#123; conut &#125;,<br>    &#125; = this;<br><br>    return (<br>      &lt;Fragment&gt;<br>        &lt;h2&gt;当前求和为：&#123;conut&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;() =&gt; this.setState(&#123; conut: conut + 1 &#125;)&#125;&gt;<br>          点我 + 1<br>        &lt;/button&gt;<br>        &lt;button<br>          onClick=&#123;() =&gt; &#123;<br>            // 强制更新<br>            this.state.conut += 1;<br>            this.forceUpdate();<br>          &#125;&#125;<br>        &gt;<br>          强制更新<br>        &lt;/button&gt;<br>        &lt;Demo conut=&#123;conut&#125; /&gt;<br>        &lt;button<br>          onClick=&#123;() =&gt; &#123;<br>            ReactDOM.unmountComponentAtNode(document.getElementById(&quot;root&quot;));<br>          &#125;&#125;<br>        &gt;<br>          卸载组件<br>        &lt;/button&gt;<br>      &lt;/Fragment&gt;<br>    );<br>  &#125;<br>&#125;<br>export default Welcome;<br><br></code></pre></td></tr></table></figure>

<h4 id="新版本生命周期"><a href="#新版本生命周期" class="headerlink" title="新版本生命周期"></a>新版本生命周期</h4><div  align="center">
<img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/20220107215836.png" width = 100% height = 100 />
</div>

<p><strong>生命周期的三个阶段</strong></p>
<ol>
<li>初始化阶段：由 ReactDom.render () 触发 - - - 初次渲染<br>constructor ()<br>getDerivedStateFromProps ()<br>render ()<br><strong>componentDidMount () 常用</strong></li>
<li>更新阶段：由组件内部的 this.setState () 或 render () 触发<br>getDerivedStateFromProps ()<br>shouldComponentUpdate ()<br><strong>render () 必用</strong><br>getSnapshotBeforeUpdate ()<br>componentDidUpdate ()</li>
<li>卸载阶段： 由 ReactDom.unmountComponentAtNode () 触发<br><strong>componentWillUnmount () 常用</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment &#125; from &quot;react&quot;;<br>import ReactDOM from &quot;react-dom&quot;;<br>class Welcome extends React.Component &#123;<br>  // 挂载 constructor getDerivedStateFromProps  render  componentDidMount<br>  // 构造器<br>  constructor(prpos) &#123;<br>    console.log(&quot;第 1 执行&quot;);<br>    super(prpos);<br>    this.state = &#123;<br>      conut: 0,<br>      num: 1,<br>    &#125;;<br>    this.num = 1;<br>  &#125;<br><br>static getDerivedStateFromProps(props, state) &#123;<br>console.log(&quot;第 2 执行&quot;, &quot;更新 1 执行&quot;);<br>return null;<br>&#125;<br>// 组件挂在完毕<br>componentDidMount() &#123;<br>console.log(&quot;第 4 执行&quot;);<br>&#125;<br><br>// 组件更新 getDerivedStateFromProps shouldComponentUpdate render getSnapshotBeforeUpdate componentDidUpdate<br>// 控制组件是否被更新<br>shouldComponentUpdate() &#123;<br>console.log(&quot;更新 2 执行&quot;);<br>const &#123; conut &#125; = this.state;<br>if (conut &gt; 3) &#123;<br>return false;<br>&#125;<br>return true;<br>&#125;<br>getSnapshotBeforeUpdate() &#123;<br>console.log(&quot;更新 4 执行&quot;);<br>return null;<br>&#125;<br>// 组件更新完毕<br>componentDidUpdate() &#123;<br>console.log(&quot;更新 5 执行&quot;);<br>&#125;<br>// 组件卸载 componentWillUnmount<br>// 组件将要卸载执行<br>componentWillUnmount() &#123;<br>console.log(&quot;卸载 1 执行&quot;);<br>&#125;<br>// 初始渲染 状态更新 执行<br>render() &#123;<br>console.log(&quot;第 3 执行&quot;, &quot;更新 3 执行&quot;);<br>const &#123;<br>state: &#123; conut &#125;,<br>&#125; = this;<br><br>    return (<br>      &lt;Fragment&gt;<br>        &lt;h2&gt;当前求和为：&#123;conut&#125;&lt;/h2&gt;<br>        &lt;button onClick=&#123;() =&gt; this.setState(&#123; conut: conut + 1 &#125;)&#125;&gt;<br>          点我 + 1<br>        &lt;/button&gt;<br>        &lt;button<br>          onClick=&#123;() =&gt; &#123;<br>            // 强制更新<br>            this.state.conut += 1;<br>            this.forceUpdate();<br>          &#125;&#125;<br>        &gt;<br>          强制更新<br>        &lt;/button&gt;<br>        &lt;button<br>          onClick=&#123;() =&gt; &#123;<br>            ReactDOM.unmountComponentAtNode(document.getElementById(&quot;root&quot;));<br>          &#125;&#125;<br>        &gt;<br>          卸载组件<br>        &lt;/button&gt;<br>      &lt;/Fragment&gt;<br>    );<br><br>&#125;<br>&#125;<br>export default Welcome;<br><br></code></pre></td></tr></table></figure>

<h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><p>计算出虚拟 DOM 中真正变化的部分，并只针对该部分进行原生 DOM 操作，而非重新渲染整个页面<br><strong>react/vue 中的 key 有什么作用：</strong> 当状态中的数据发生改变时，react 会根据【新数据】生成【新虚拟 DOM】，随后 react 会进行【新虚拟 DOM】和【旧虚拟 DOM】的 diff 算法比较，具体的比较规则如下：</p>
<ol>
<li>若【旧 DOM】中找到了与【新 DOM】相同的 key，则会进一步判断两者的内容是否相同，如果也一样，则直接使用之前的真实 DOM，如果内容不一样，则会生成新的真实 DOM，替换掉原先的真实 DOM</li>
<li>若【旧 DOM】中没找到与【新 DOM】相同的 key，则直接生成新的真实 DOM，然后渲染到页面</li>
</ol>
<p><strong>用 index 作为 key 可能引发的问题：</strong></p>
<ol start="3">
<li>若对数据进行：逆序添加、逆序删除等破坏顺序的操作时会产生不必要的真实 DOM 更新，造成效率低下</li>
<li>如果结构中还包含输入类的 dom，会产生错误 dom 更新，出现界面异常</li>
</ol>
<p><strong>开发中如何选择 key：</strong><br>5. 最好选中标签的唯一标识 id、手机号等<br>6. 如果只是简单的展示数据，用 index 也是可以的</p>
<h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><h4 id="安装脚手架"><a href="#安装脚手架" class="headerlink" title="安装脚手架"></a>安装脚手架</h4><p>使用 create-react-app（脚手架工具）创建一个初始化项目</p>
<ol>
<li>下载脚手架工具：npm i -g create-react-app</li>
<li>创建应用项目：create-react-app my-app</li>
<li>运行应用：cd my-app（进入应用文件夹），npm start（启动应用）</li>
</ol>
<h4 id="React-脚手架配置代理"><a href="#React-脚手架配置代理" class="headerlink" title="React 脚手架配置代理"></a>React 脚手架配置代理</h4><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p><strong>在 package.json 中追加如下配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&quot;proxy&quot;:&quot;http://localhost:5000&quot;<br><br></code></pre></td></tr></table></figure>

<p>1、优点：配置简单，前端请求资源可以不加任何前缀<br>2、缺点：不能配置多个代理（如果请求的不同服务器就不行）<br>3、工作方式：当请求了自身 3000 端口不存在的资源时，那么会转发给 5000 端口（优先会匹配自身的资源，如果自己有就不会请求 5000 端口了）</p>
<h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p><strong>在 src 下创建配置文件：src/setupProxy.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">const proxy = require(&quot;http-proxy-middleware&quot;);<br>module.exports = function (app) &#123;<br>  app.use(<br>    proxy(&quot;/api&quot;, &#123;<br>      target: &quot;http://localhost:4000/&quot;,<br>      changeOrigin: true,<br>      pathRewrite: &#123; &quot;^/api&quot;: &quot;&quot; &#125;,<br>    &#125;),<br>    proxy(&quot;/api2&quot;, &#123;<br>      target: &quot;http://localhost:5000/&quot;,<br>      changeOrigin: true,<br>      pathRewrite: &#123; &quot;^/api2&quot;: &quot;&quot; &#125;,<br>    &#125;)<br>  );<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p>1、优点：可以配置多个代理，可以灵活控制请求是否走代理<br>2、缺点：配置繁琐，前端请求资源时必须加前缀</p>
<h3 id="消息订阅-发布机制"><a href="#消息订阅-发布机制" class="headerlink" title="消息订阅-发布机制"></a>消息订阅-发布机制</h3><p>原先 react 传递数据基本用的是 props，而且只能父组件传给子组件，如果子组件要传数据给父组件，只能先父组件传一个函数给子组件，子组件再调用该方法，把数据作为形参传给父组件，那考虑一个事情，兄弟间组件要如何传递数据呢？这就要引出下面这个消息订阅-发布机制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install pubsub-js --save<br></code></pre></td></tr></table></figure>

<p>使用：</p>
<ol>
<li>先引入：import PubSub from “pubsub-js”</li>
<li>传递数据方发布：PubSub.publish(‘消息名’,data)</li>
<li>要接收数据方订阅：PubSub.subscribe(‘消息名’，（data）=&gt;{ console.log(data) })</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment &#125; from &quot;react&quot;;<br>import PubSub from &quot;pubsub-js&quot;;<br>class Demo extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;button<br>        onClick=&#123;() =&gt; &#123;<br>          PubSub.publish(&quot;showNum&quot;, &#123; num: 1 &#125;);<br>        &#125;&#125;<br>      &gt;<br>        点击<br>      &lt;/button&gt;<br>    );<br>  &#125;<br>&#125;<br>class Content extends React.Component &#123;<br>  state = &#123;<br>    num: 0,<br>  &#125;;<br>  componentDidMount() &#123;<br>    this.token = PubSub.subscribe(&quot;showNum&quot;, (_, setObjs) =&gt; &#123;<br>      this.setState(setObjs);<br>    &#125;);<br>  &#125;<br>  componentWillUnmount() &#123;<br>    PubSub.unsubscribe(this.token);<br>  &#125;<br>  render() &#123;<br>    const &#123; num &#125; = this.state;<br>    return &lt;div&gt;&#123;num&#125;&lt;/div&gt;;<br>  &#125;<br>&#125;<br>class App extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;Fragment&gt;<br>        &lt;Demo /&gt;<br>        &lt;Content /&gt;<br>      &lt;/Fragment&gt;<br>    );<br>  &#125;<br>&#125;<br>export default App;<br><br></code></pre></td></tr></table></figure>

<h3 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h3><h4 id="学习文档"><a href="#学习文档" class="headerlink" title="学习文档"></a>学习文档</h4><ol>
<li>英文文档: <a href="https://redux.js.org/">https://redux.js.org/</a></li>
<li>中文文档: <a href="https://redux.org.cn/">https://redux.org.cn/</a></li>
<li>GitHub 地址: <a href="https://github.com/reactis/redux">https://github.com/reactis/redux</a></li>
</ol>
<h4 id="redux-是什么"><a href="#redux-是什么" class="headerlink" title="redux 是什么"></a>redux 是什么</h4><ol>
<li>它是专门做状态管理的 js 库，不是 react 插件库</li>
<li>它可以用在 angular、vue、react 等项目中，但与 react 配合用到最多</li>
<li>作用：集中式管理 react 应用中多个组件共享的状态</li>
</ol>
<h4 id="什么情况下需要使用它"><a href="#什么情况下需要使用它" class="headerlink" title="什么情况下需要使用它"></a>什么情况下需要使用它</h4><ol>
<li>某个组件的状态需要让其他组件也能拿到</li>
<li>一个组件需要改变另一个组件的状态（通信）</li>
<li>总体原则：能不用就不用，如果不用比较吃力，就可以使用</li>
</ol>
<h4 id="redux-的工作流程"><a href="#redux-的工作流程" class="headerlink" title="redux 的工作流程"></a>redux 的工作流程</h4><div  align="center">
<img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/20220323221342.png" width = 100% height = 100 />
</div>

<h4 id="redux-的三个核心概念"><a href="#redux-的三个核心概念" class="headerlink" title="redux 的三个核心概念"></a>redux 的三个核心概念</h4><h5 id="action"><a href="#action" class="headerlink" title="action"></a>action</h5><ol>
<li>动作的对象</li>
<li>包含 2 个属性</li>
</ol>
<ul>
<li>标识属性，值为字符串，唯—，必要属性</li>
<li>数据属性，值类型任意，可选属性</li>
</ul>
<ol start="3">
<li>栗子：type: { ‘ADD’, data : { name: “tom”, age:18} }</li>
</ol>
<h4 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h4><ol>
<li>用于初始化状态、加工状态</li>
<li>加工时，根据旧的 state 和 action，产生新的 state 的纯函数</li>
</ol>
<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><ol>
<li>将 state、 action、 reducer 联系在一起的对象</li>
</ol>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>React中使用axios发送请求</title>
    <url>/2023/03/13/React%E4%B8%AD%E4%BD%BF%E7%94%A8axios%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP client</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul>
<li>从浏览器创建 XMLHttpRequests</li>
<li>从node.js 发出 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求(request) 和响应(response)</li>
<li>转换请求和响应数据</li>
<li>终止请求</li>
<li>自动转换 JSON 数据</li>
<li>Client 端支持防范 XSRF</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install axios --save<br></code></pre></td></tr></table></figure>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import axios from &#x27;axios&#x27;     // 第一步引入 axios<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            navs: [],<br>        &#125;<br>    &#125;<br>    componentDidMount() &#123;    // 第二步在此生命周期函数中发送请求<br>        // axios后面直接跟 url 地址 ， 在使用 .then方法<br>        axios.get(&quot;http://vueshop.glbuys.com/api/home/index/slide?token=1ec949a15fb709370f&quot;).then((res) =&gt; &#123;<br>            console.log(res)<br>            if (res.status === 200) &#123;<br>                this.setState(&#123; navs: res.data.data &#125;)<br>            &#125; else &#123;<br>                alert(&quot;请求失败&quot;)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;ul&gt;<br>                    &#123;this.state.navs.map((item, index) =&gt; &#123;    // 第三步渲染数据<br>                        return (<br>                            &lt;li key=&#123;index&#125;&gt;&#123;item.title&#125;&lt;/li&gt;<br>                        )<br>                    &#125;)&#125;<br>                &lt;/ul&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<h3 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import axios from &#x27;axios&#x27;     // 第一步引入 axios<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            phone: &quot;&quot;,<br>            password: &quot;&quot;,<br>        &#125;<br>    &#125;<br>    componentDidMount() &#123;        // 第二步在此生命周期函数中发送请求<br>        // axios后面直接跟 url 地址 ， 在使用 .then方法<br>        axios.post(&quot;http://vueshop.glbuys.com/api/home/index/slide?token=1ec949a15fb709370f&quot;, &#123;<br>            // 第三步传递需要的数据      clellphone,    password这是需要传递的数据<br>            clellphone: this.state.phone,<br>            password: this.state.password<br>        &#125;).then((res) =&gt; &#123;<br>            if (res.status === 200) &#123;<br>               console.log(&quot;请求成功&quot;,res)<br>            &#125; else &#123;<br>                alert(&quot;请求失败&quot;)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<h3 id="上传本地文件"><a href="#上传本地文件" class="headerlink" title="上传本地文件"></a>上传本地文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import axios from &#x27;axios&#x27;     // 第一步引入 axios<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            num: 0,<br>        &#125;<br>    &#125;<br>    upHead(e) &#123;<br>        let headFile = e.target.files[0];<br>        let data = new FormData();<br>        data.append(&quot;headfile&quot;, headFile);<br>        var config = &#123;<br>            onUploadProgress: (progressEvent) =&gt; &#123;<br>                // 进度条<br>                var percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);<br>                this.setState(&#123; num: percentCompleted &#125;, () =&gt; &#123;<br>                    if (this.state.num === 100) &#123;<br>                        this.setState(&#123; num: 0 &#125;)<br>                    &#125;<br>                &#125;)<br>            &#125;<br>        &#125;;<br>        axios.post(&quot;http://vueshop.glbuys.com/api/user/myinfo/formdatahead?token=1ec949a15fb709370f&quot;,<br>            data, config).then(res =&gt; &#123;<br>                console.log(res);<br>                if (res.data.code === 200) &#123;<br>                    this.setState(&#123; showHead: &quot;http://vueshop.glbuys.com/userfiles/head/&quot; + res.data.data.msbox &#125;)<br>                &#125;<br>            &#125;)<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                上传头像 : &lt;input type=&quot;file&quot; onChange=&#123;this.upHead.bind(this)&#125; /&gt; &lt;br /&gt;<br>                 头像预览 : &#123;this.state.showHead !== &quot;&quot; ? &lt;img src=&#123;this.state.showHead&#125; alt=&quot;&quot; style=&#123;&#123; width: 200, height: 200 &#125;&#125; /&gt; : &quot;&quot;&#125;&lt;br /&gt;<br>                 进度条预览 : &lt;div style=&#123;&#123; width: 300, height: 25, border: 1, &#125;&#125;&gt;<br>                    &lt;div style=&#123;&#123; height: 100 + &#x27;%&#x27;, width: this.state.num + &quot;%&quot;, background: &quot;green&quot; &#125;&#125;&gt;&lt;/div&gt;<br>                &lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<h2 id="封装请求"><a href="#封装请求" class="headerlink" title="封装请求"></a>封装请求</h2><p>建立 reques.js文件，内容如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import axios from &#x27;axios&#x27;<br>export function request(url, method = &quot;get&quot;, data = &#123;&#125;, config = &#123;&#125;) &#123;<br>    return axiosRequest(url, method, data, config)<br>&#125;<br>function axiosRequest(url, method, data, config) &#123;<br>    if (method.toLocaleLowerCase() === &quot;post&quot;) &#123;<br>        let params = new URLSearchParams();       <br>        if (data instanceof Object) &#123;              //如果后端格式为 raw    从此开始注释<br>            for (let key in data) &#123;<br>                params.append(key, data[key]);<br>            &#125;<br>            data = params;                        // 此处注释结束<br>        &#125;                       <br>    &#125; else if (method.toLocaleLowerCase() === &quot;file&quot;) &#123;<br>        method = &quot;post&quot;;<br>        let params = new FormData();<br>        if (data instanceof Object) &#123;<br>            for (let key in data) &#123;<br>                params.append(key, data[key]);<br>            &#125;<br>            data = params;<br>        &#125;<br>    &#125;<br>    let axiosConfig = &#123;<br>        url: url,<br>        method: method.toLocaleLowerCase(),<br>        data: data<br>    &#125;;<br>    if (config instanceof Object) &#123;<br>        for (let key in config) &#123;<br>            axiosConfig[key] = config[key];<br>        &#125;<br>    &#125;<br>    return axios(axiosConfig).then(res =&gt; res.data);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="GET请求-1"><a href="#GET请求-1" class="headerlink" title="GET请求"></a>GET请求</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123; request &#125; from &#x27;../../utils/reques&#x27;;    // 第一步引入方法<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            navs: [],<br>        &#125;<br>    &#125;<br>    componentDidMount() &#123;    // 第二步在此生命周期函数中发送请求<br>        // 调用此方法，第一位参数为请求地址，第二位参数为请求方式<br>        request(&quot;http://vueshop.glbuys.com/api/home/index/slide?token=1ec949a15fb709370f&quot;,&quot;get&quot;).then(res =&gt; &#123;<br>            if (res.code === 200) &#123;<br>                this.setState(&#123; navs: res.data &#125;)<br>            &#125; else &#123;<br>                alert(&quot;请求失败&quot;)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;ul&gt;<br>                    &#123;this.state.navs.map((item, index) =&gt; &#123;    // 第三步渲染数据<br>                        return (<br>                            &lt;li key=&#123;index&#125;&gt;&#123;item.title&#125;&lt;/li&gt;<br>                        )<br>                    &#125;)&#125;<br>                &lt;/ul&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<h3 id="POST请求-1"><a href="#POST请求-1" class="headerlink" title="POST请求"></a>POST请求</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123; request &#125; from &#x27;../../utils/reques&#x27;;       // 第一步引入方法<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            phone: &quot;&quot;,<br>            password: &quot;&quot;,<br>        &#125;<br>    &#125;<br>    componentDidMount() &#123;        // 第二步在此生命周期函数中发送请求<br>        // 调用此方法，第一位参数为请求地址，第二位参数为请求方式，第三位参数为需要传递的数据<br>        request(&quot;http://vueshop.glbuys.com/api/home/index/slide?token=1ec949a15fb709370f&quot;, &quot;post&quot;, &#123;<br>            clellphone: this.state.phone,<br>            password: this.state.password<br>        &#125;.then((res) =&gt; &#123;<br>            if (res.code === 200) &#123;<br>                this.props.dispatch(actions.user.login(&#123; username: this.state.username, isLogin: true &#125;))<br>            &#125; else &#123;<br>                alert(&quot;请求失败&quot;)<br>            &#125;<br>        &#125;))<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<h3 id="上传本地文件-1"><a href="#上传本地文件-1" class="headerlink" title="上传本地文件"></a>上传本地文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123; request &#125; from &#x27;../../utils/reques&#x27;;    // 第一步引入方法<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            num: 0,<br>        &#125;<br>    &#125;<br>    upHead(e) &#123;<br>        let headFile = e.target.files[0];<br>        var config = &#123;<br>            onUploadProgress: (progressEvent) =&gt; &#123;<br>                // 进度条<br>                var percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);<br>                this.setState(&#123; num: percentCompleted &#125;, () =&gt; &#123;<br>                    if (this.state.num === 100) &#123;<br>                        this.setState(&#123; num: 0 &#125;)<br>                    &#125;<br>                &#125;)<br>            &#125;<br>        &#125;;<br>         // 调用此方法，第一位参数为请求地址，第二位参数为请求方式,这里 file 方法中改为为了 post<br>        request(&quot;http://vueshop.glbuys.com/api/user/myinfo/formdatahead?token=1ec949a15fb709370f&quot;, &quot;file&quot;, &#123;<br>            headfile: headFile<br>        &#125;, config).then(res =&gt; &#123;<br>            if (res.code === 200) &#123;<br>                this.setState(&#123; showHead: &quot;http://vueshop.glbuys.com/userfiles/head/&quot; + res.data.msbox &#125;)<br>            &#125; else &#123;<br>                alert(&quot;请求失败&quot;)<br>            &#125;<br>        &#125;)<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                上传头像 : &lt;input type=&quot;file&quot; onChange=&#123;this.upHead.bind(this)&#125; /&gt; &lt;br /&gt;<br>                 头像预览 : &#123;this.state.showHead !== &quot;&quot; ? &lt;img src=&#123;this.state.showHead&#125; alt=&quot;&quot; style=&#123;&#123; width: 200, height: 200 &#125;&#125; /&gt; : &quot;&quot;&#125;&lt;br /&gt;<br>                 进度条预览 : &lt;div style=&#123;&#123; width: 300, height: 25, border: 1, &#125;&#125;&gt;<br>                    &lt;div style=&#123;&#123; height: 100 + &#x27;%&#x27;, width: this.state.num + &quot;%&quot;, background: &quot;green&quot; &#125;&#125;&gt;&lt;/div&gt;<br>                &lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>React组件的使用</title>
    <url>/2020/10/25/React%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="组件的意义"><a href="#组件的意义" class="headerlink" title="组件的意义"></a>组件的意义</h2><p>React通过组件的思想，将界面拆分成一个个<code>可复用</code>的模块，每一个模块就是一个React 组件。一个React 应用由若干组件组合而成，一个复杂组件也可以由若干简单组件组合而成。</p>
<h2 id="创建组件方式"><a href="#创建组件方式" class="headerlink" title="创建组件方式"></a>创建组件方式</h2><p>组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。<br><strong>定义组件的两个要求:</strong></p>
<ol>
<li>组件名称必须以大写字母开头</li>
<li>组件的返回值只能有一个根元素</li>
</ol>
<h3 id="1-无状态组件"><a href="#1-无状态组件" class="headerlink" title="1. 无状态组件"></a>1. 无状态组件</h3><ol>
<li>就是一个函数</li>
<li>没有生命周期函数</li>
<li>不能使用state,只会接收一个props形参,并且直接使用props参数不需要this</li>
<li>无状态组件就是一个简单的视图函数，没有业务逻辑更纯粹的展示UI</li>
</ol>
<p><strong>代码示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function Welcome() &#123;<br>  return (<br>    &lt;div&gt;无状态组件&lt;/div&gt;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-有状态组件"><a href="#2-有状态组件" class="headerlink" title="2. 有状态组件"></a>2. 有状态组件</h3><ol>
<li>是一个class类，继承了类的组件是有状态组件,继承自Component类</li>
<li>可以使用state和props,并且都是使用this来调用this.state或this.props</li>
<li>拥有生命周期函数</li>
<li>有状态组件可以使用生命周期可以在里面写业务逻辑，可以在里面做任何事情</li>
</ol>
<p><strong>代码示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">class Welcome extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>      name: &quot;有状态组件&quot;<br>    &#125;<br>  &#125;;<br>  componentWillMount() &#123; // 生命钩子函数，此钩子函数可以在这里做一些业务初始化操作，或者设置组件状态。<br>    this.setState(&#123; name: &quot;你好,我是有状态组件&quot; &#125;)<br>  &#125;<br>  render() &#123;<br>    return (<br>      &lt;div&gt;&#123;this.state.name&#125;&lt;/div&gt;<br>      // 此时页面上的展示的是 : 你好,我是有状态组件<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-高阶组件"><a href="#3-高阶组件" class="headerlink" title="3. 高阶组件"></a>3. 高阶组件</h3><p><strong>高阶组件类似高阶函数</strong>  </p>
<ol>
<li><strong>高阶函数</strong><br>高阶函数就是一个函数，但 <code>参数</code> 和 <code>返回值</code> 为 <code>函数</code> <figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function hoc() &#123;<br>    return function (args) &#123;<br>        console.log(args)<br>    &#125;<br>&#125;<br>hoc()(&quot;我是高级函数&quot;)<br></code></pre></td></tr></table></figure></li>
<li><strong>高阶组件</strong><br>高阶组件也是一个函数，但 <code>参数</code> 和 <code>返回值</code>为 <code>组件</code></li>
</ol>
<p> <strong>其实就是定义一个函数，里面返回一个有状态组件，就是高阶组件</strong><br>高阶组件就像我们吃火锅的锅底，可以在里面加羊肉、牛肉、蔬菜等。锅底相当于业务逻辑，食物相当于UI展示，可以使我们的业务逻辑层和UI层分离，代码更加清晰，更适合多人开发和维护</p>
<p><strong>高阶组件分为两种</strong></p>
<ol>
<li><strong>属性代理方式 :</strong><br>属性代理是最常见的高阶组件的使用方式。他通过一些操作，将包裹的组件的 <code>props</code> 和新生成的 <code>props</code>一起传递给此组件，这称之为属性代理  </li>
</ol>
<p>  <strong>特点:</strong> 返回一个全新的组件，不可以获取输入组件的state、生命周期、方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>// 属性代理<br>function Hoc(WithComponent, title) &#123; //WithComponent：接收传过来的组件，title：接收传来的参数<br>  return class HocComponent extends React.Component &#123;  //return一个有状态组件  继承于React.Component<br>    render() &#123;<br>      return (<br>        &lt;React.Fragment&gt;<br>          &#123;/* name：传递的参数 */&#125;<br>          &lt;WithComponent name=&quot;我是属性代理高阶组件&quot;&gt;&lt;/WithComponent&gt;<br>          &lt;div&gt;&#123;title&#125;&lt;/div&gt;<br>        &lt;/React.Fragment&gt;<br>      )<br>    &#125;<br>  &#125;<br>&#125;<br>class App extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>    &#125;<br>  &#125;;<br>  render() &#123;<br>    return (<br>      // 使用 props 接收传递过来的参数<br>      &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>export default Hoc(App, &quot;我是属性代理高阶组件参数&quot;); //App:传递的组件<br></code></pre></td></tr></table></figure>
<ol start="2">
<li><strong>反向继承方式 :</strong><br>反向继承返回的React组件继承了被传入的组件，它能够访问的区域、权限更多，相比属性代理方式，它更像打入组织的内部，对其进行修改  </li>
</ol>
<p>  <strong>特点:</strong> 返回输入组件的子组件，可以获取输入组件的state、生命周期、方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>// 反向继承<br>function Hoc(WithComponent, title) &#123; //WithComponent：接收传过来的组件，title：接收传来的参数<br>  return class HocComponent extends WithComponent &#123;  //return一个有状态组件  继承传来过来的组件<br>    render() &#123;<br>      return (<br>        &lt;React.Fragment&gt;<br>          &lt;div&gt;&#123;title&#125;&lt;/div&gt;<br>          &#123;/* 可以访问传递过来组件 state 中的数据 */&#125;<br>          &#123;this.state.users&#125;<br>          &#123;/* name：传递的参数 */&#125;<br>          &lt;WithComponent name=&quot;我是反向继承高阶组件&quot;&gt;&lt;/WithComponent&gt;<br>        &lt;/React.Fragment&gt;<br>      )<br>    &#125;<br>  &#125;<br>&#125;<br>class App extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>      users: &quot;鸣人&quot;<br>    &#125;<br>  &#125;;<br>  render() &#123;<br>    return (<br>      // 使用 props 接收传递过来的参数<br>      &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br>export default Hoc(App, &quot;我是反向继承高阶组件参数&quot;); //App:传递的组件 <br></code></pre></td></tr></table></figure>
<h2 id="组件之间的传值"><a href="#组件之间的传值" class="headerlink" title="组件之间的传值"></a>组件之间的传值</h2><h3 id="1-父向子传值"><a href="#1-父向子传值" class="headerlink" title="1. 父向子传值"></a>1. 父向子传值</h3><p><strong>无状态组件直接使用props参数不需要this</strong><br><strong>有状态组件必须使用this.props</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import PropTypes from &#x27;prop-types&#x27;     //检测数据类型<br>// 父组件<br>class Father extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>      name: &quot;小灰灰&quot;<br>    &#125;<br>  &#125;;<br>  render() &#123;<br>    const &#123; name &#125; = this.state<br>    return (<br>      &lt;React.Fragment&gt;<br>        &#123;/* title    isShow    myName父组件要传递给子组件的属性 */&#125;<br>        &lt;Child title=&quot;父组件给子组件传值&quot; isShow=&#123;true&#125; myName=&#123;name&#125; /&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>// 子组件<br>class Child extends React.Component &#123;<br>  constructor() &#123;<br>    super();<br>    this.state = &#123;<br>    &#125;<br>  &#125;;<br>  render() &#123;<br>    const &#123; myName &#125; = this.props<br>    return (<br>      &lt;React.Fragment&gt;<br>        &#123;/* 父组件向子组件传递属性，子组件使用 props 属性接收 */&#125;<br>        &#123;this.props.title&#125;<br>        &lt;div style=&#123;this.props.isShow ? &#123; display: &#x27;block&#x27; &#125; : &#123; display: &#x27;none&#x27; &#125;&#125;&gt;我是一个盒子&lt;/div&gt;<br>        &lt;h4&gt;我的名字: &#123;myName&#125;&lt;/h4&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>//检测属性值的类型<br>Child.propTypes = &#123;<br>  title: PropTypes.string.isRequired,  //isRequired：检查是否为必填项<br>  isShow: PropTypes.bool,<br>  myName: PropTypes.string,<br>  // <br>&#125;<br>//默认传递属性值<br>Child.defaultProps = &#123;<br>  title: &quot;默认传递&quot;  //如果父组件没有传递title属性，默认传递此属性值<br>&#125;<br>export default Father;<br><br></code></pre></td></tr></table></figure>
<h3 id="2-子向父传值"><a href="#2-子向父传值" class="headerlink" title="2. 子向父传值"></a>2. 子向父传值</h3><p><strong>如果子组件对父组件进行传值，则需要通过事件触发，子组件调用在父组件中的方法，并以传递参数的形式来将子组件中的state传递给父组件</strong><br><strong>父组件:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;<br>import Son from &#x27;./son&#x27;;<br>class App extends React.Component&#123;<br>    constructor() &#123;<br>        super();<br>        this.state=&#123;<br>        msg:&quot;&quot;<br>        &#125;<br>    &#125;<br>    getChildren(val) &#123;<br>        this.setState(&#123;msg:val&#125;)<br><br>    &#125;<br>    render() &#123;<br>        return(<br>            &lt;div&gt;<br>                &lt;Son sendParent=&#123;this.getChildren.bind(this)&#125; /&gt;<br>                &#123;this.state.msg&#125;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<p><strong>子组件:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class Son extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            msg: &quot;我是子组件的值&quot;<br>        &#125;<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;div&gt;<br>              &lt;button type=&quot;button&quot; onClick=&#123;this.props.sendParent.bind(this,this.state.msg)&#125;&gt;请点击我&lt;/button&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br>export default Son<br></code></pre></td></tr></table></figure>
<h2 id="组件之间传递方法"><a href="#组件之间传递方法" class="headerlink" title="组件之间传递方法"></a>组件之间传递方法</h2><h3 id="父向子传递方法"><a href="#父向子传递方法" class="headerlink" title="父向子传递方法"></a>父向子传递方法</h3><p><strong>父组件:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import Son from &quot;./son&quot;<br>class Father extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            msg: &quot;我是父组件中的方法&quot;<br>        &#125;<br>    &#125;<br>    parent() &#123;<br>        alert(this.state.msg)<br>    &#125;<br>    render() &#123;<br>        return(<br>            &lt;div&gt;<br>                &lt;Son parentMethod=&#123;this.parent.bind(this)&#125; /&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br>export default Father<br></code></pre></td></tr></table></figure>
<p><strong>子组件:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class Son extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state=&#123;&#125;<br>    &#125;<br>    render() &#123;<br>        return(<br>            &lt;div&gt;<br>                &lt;button onClick=&#123;this.props.parentMethod.bind(this)&#125;&gt;点我&lt;/button&gt;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br>export default Son;<br></code></pre></td></tr></table></figure>
<h3 id="子向父传递方法"><a href="#子向父传递方法" class="headerlink" title="子向父传递方法"></a>子向父传递方法</h3><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="1-登录案例"><a href="#1-登录案例" class="headerlink" title="1. 登录案例"></a>1. 登录案例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &quot;react&quot;<br>import Hoc from &quot;./proxy&quot;<br><br>const Login = Hoc((props) =&gt; &#123;     //将此无状态组件传递到./proxy<br>    console.log(&#123; ...props.username &#125;)<br>    return (<br>        &lt;React.Fragment&gt;<br>            &#123;/* 传递过来的参数 */&#125;<br>            &lt;div&gt;&#123;props.title&#125; &#123;props.id&#125;&lt;/div&gt;<br>            用index户名: &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; &#123;...props.username&#125; /&gt; &#123;props.username.value&#125;<br>            &#123;props.nulls.isNullusername ? &quot;请输入用户名&quot; : &quot;&quot;&#125;<br>            &lt;br /&gt;<br>            密码: &lt;input type=&quot;password&quot; placeholder=&quot;请输入密码&quot; &#123;...props.password&#125; /&gt; &#123;props.password.value&#125;<br>            &#123;props.nulls.isNullpassword ? &quot;请输入用密码&quot; : &quot;&quot;&#125;<br>            &lt;br /&gt;<br>            &lt;button type=&quot;button&quot; onClick=&#123;props.submit.bind(this, () =&gt; &#123;<br>                alert(&#x27;提交数据&#x27;)<br>            &#125;)&#125;&gt;登录&lt;/button&gt;<br>        &lt;/React.Fragment&gt;<br><br>    )<br>&#125;)<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br><br>        &#125;<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;Login title=&quot;会员登录&quot; id=&quot;1&quot;&gt;&lt;/Login&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//proxy文件<br>// 属性代理<br>import React from &quot;react&quot;<br>export default function Hoc(WithComponent) &#123;              //接收组件<br>    return class HocComponent extends React.Component &#123;   //继承于React.Component<br>        constructor() &#123;<br>            super();<br>            this.state = &#123;<br>                username: &quot;&quot;,<br>                password: &quot;&quot;,<br>                isNullusername: false,<br>                isNullpassword: false<br>            &#125;<br>        &#125;<br>        setUsername(e) &#123;<br>            this.setState(&#123; username: e.target.value &#125;)<br>        &#125;<br>        setPassword(e) &#123;<br>            this.setState(&#123; password: e.target.value &#125;)<br>        &#125;<br>        submitData(callback) &#123;     //提交数据<br>            if(this.state.username.match(/`\s*$/))&#123;<br>                this.setState(&#123;isNullusername:true&#125;)<br>                return;<br>            &#125;<br>            if(this.state.username.match(/`\s*$/))&#123;<br>                this.setState(&#123;isNullpassword:true&#125;)<br>                return;<br>            &#125;<br>            if(typeof callback===&#x27;function&#x27;) &#123;<br>                callback();<br>            &#125;<br>        &#125;<br>        render() &#123;<br>            let newProps = &#123;<br>                username: &#123; // 用户名<br>                    onChange: this.setUsername.bind(this),<br>                    value: this.state.username<br>                &#125;,<br>                password: &#123; //用户密码<br>                    onChange: this.setPassword.bind(this),<br>                    value: this.state.password<br>                &#125;,<br>                nulls:&#123;  //  显示条件<br>                    isNullusername: this.state.isNullusername,<br>                    isNullpassword: this.state.isNullpassword,<br>                &#125;<br>            &#125;<br>            <br>            return (<br>                &lt;React.Fragment&gt;<br>                    &#123;/* &lt;WithComponent title=&#123;this.props.title&#125; &#123;...this.props&#125; setUsername=&#123;this.setUsername.bind(this)&#125; username=&#123;this.state.username&#125;&gt;&lt;/WithComponent&gt; */&#125;<br>                    &#123;/*WithComponent 传递过来得组件。  传入的参数过多时，采用扩展运算符无限获取参数 */&#125;<br>                    &lt;WithComponent  &#123;...this.props&#125; &#123;...newProps&#125; submit=&#123;this.submitData.bind(this)&#125;&gt;&lt;/WithComponent&gt;<br>                &lt;/React.Fragment&gt;<br>            )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-轮播图案例"><a href="#2-轮播图案例" class="headerlink" title="2. 轮播图案例"></a>2. 轮播图案例</h3><p><strong>父组件 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//轮播图数据源<br>import React from &#x27;react&#x27;<br>import Swiper from &#x27;../../components/swiper&#x27;<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            images: [<br>                &#123; src: require(&quot;../../assets/images/banner1.jpg&quot;), url:&quot;https//baidu.com&quot;&#125;,<br>                &#123; src: require(&quot;../../assets/images/banner2.jpg&quot;), url:&quot;https//baidu.com&quot;&#125;,<br>                &#123; src: require(&quot;../../assets/images/banner3.jpg&quot;), url:&quot;https//baidu.com&quot;&#125;,<br>                &#123; src: require(&quot;../../assets/images/banner3.jpg&quot;), url:&quot;https//baidu.com&quot;&#125;,<br>            ]<br>        &#125;<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;Swiper data=&#123;this.state.images&#125; /&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//轮播图逻辑<br>import React from &#x27;react&#x27;;<br>import Proptypes from &#x27;prop-types&#x27;;<br>export default function Hoc(WithCompont) &#123;<br>    return class HocCompont extends React.Component &#123;<br>        static propTypes = &#123;  //检测传递过来的数据类型<br>            data: Proptypes.array.isRequired   //isRequired为必填项<br>        &#125;<br>        static defaultProps = &#123; //默认值<br>            data: []<br>        &#125;<br>        constructor(props) &#123;<br>            super(props);<br>            this.state = &#123;<br>                data: []<br>            &#125;<br>            this.aData = []<br>            this.isInit = true<br>            this.timer = null<br>            this.index = 0<br>        &#125;<br>        change(index) &#123;   //点击切换图片<br>            this.isInit = false<br>            this.index = index<br>            if (this.aData.length &gt; 0) &#123;<br>                for (let i = 0; i &lt; this.aData.length; i++) &#123;<br>                    if (this.aData[i].active) &#123;<br>                        this.aData[i].active = false;<br>                        break;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            this.aData[index].active = true;<br>            this.setState(&#123; data: this.aData &#125;)<br><br>        &#125;<br>        autoPlay() &#123;//自动播放<br>            this.timer = setInterval(() =&gt; &#123;<br>                if (this.aData.length &gt; 0) &#123;<br>                    this.isInit = false;<br>                    for (let i = 0; i &lt; this.aData.length; i++) &#123;<br>                        if (this.aData[i].active) &#123;<br>                            this.aData[i].active = false;<br>                            break;<br>                        &#125;<br>                    &#125;<br>                    if (this.index &gt;= this.aData.length - 1) &#123;<br>                        this.index = 0;<br>                    &#125; else &#123;<br>                        this.index++<br>                        console.log(this.index)<br>                    &#125;<br>                    this.aData[this.index].active = true;<br>                    this.setState(&#123; data: this.aData &#125;)<br>                &#125;<br><br>            &#125;, (3000))<br>        &#125;<br>        stop() &#123; //鼠标经过清除定时器<br>            clearInterval(this.timer)<br>        &#125;<br>        componentDidMount() &#123;<br>            this.setState(&#123; data: this.props.data &#125;)<br>            this.autoPlay();  //开启定时器<br>        &#125;<br>        componentWillUnmount() &#123;<br>            clearInterval(this.timer)  //清除定时器<br><br>        &#125;<br>        render() &#123;<br>            console.log(this.props)   //父组件传递过来的参数<br>            this.aData = this.props.data;<br>            if (this.aData &amp;&amp; this.aData.length &gt; 0 &amp;&amp; this.isInit) &#123;<br>                for (let i = 0; i &lt; this.aData.length; i++) &#123;<br>                    if (i == 0) &#123;<br>                        this.aData[i].active = true;<br>                    &#125; else &#123;<br>                        this.aData[i].active = false<br>                    &#125;<br>                &#125;<br>            &#125;<br>            return (<br>                //传递参数以及方法<br>                &lt;WithCompont &#123;...this.props&#125; change=&#123;this.change.bind(this)&#125; stop=&#123;this.stop.bind(this)&#125; autoPlay=&#123;this.autoPlay.bind(this)&#125;&gt;&lt;/WithCompont&gt;<br>            )<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//轮播图视图层<br>import React from &#x27;react&#x27;<br>import Hoc from &#x27;./hoc&#x27;<br>import &quot;./style.css&quot;<br>// export default function hoc()&#123;<br>export default Hoc((props) =&gt; &#123;<br>    console.log(props)<br>    let aData = props.data;<br>    return (<br>        &lt;div className=&quot;banner&quot;&gt;<br>            &lt;div className=&quot;my-swiper-main&quot; onMouseOver=&#123;props.stop.bind(this)&#125; onMouseOut=&#123;props.autoPlay.bind(this)&#125;&gt;<br>                &#123;<br>                    aData.length &gt; 0 &amp;&amp; aData.map((item, index) =&gt; &#123;<br>                        return (<br>                            &lt;div className=&#123;item.active ? &quot;my-slide show&quot; : &quot;my-slide&quot;&#125; key=&#123;index&#125;&gt;<br>                                &lt;a href=&#123;item.url&#125; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;<br>                                    &lt;img src=&#123;item.src&#125; alt=&quot;&quot; /&gt;<br>                                &lt;/a&gt;<br>                            &lt;/div&gt;<br>                        )<br>                    &#125;)<br>                &#125;<br>                &lt;div className=&quot;pagination&quot;&gt;<br>                    &#123;<br>                        aData.length &gt; 0 &amp;&amp; aData.map((item, index) =&gt; &#123;<br>                            return (<br>                                &lt;div className=&#123;item.active ? &quot;dot active&quot; : &quot;dot&quot;&#125; key=&#123;index&#125; onClick=&#123;props.change.bind(this, index)&#125;&gt;&lt;/div&gt;<br>                            )<br>                        &#125;)<br>                    &#125;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;)<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React创建组件</tag>
        <tag>React组件传值</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue入坑</title>
    <url>/2023/03/13/Vue%E5%85%A5%E5%9D%91/</url>
    <content><![CDATA[<h3 id="Vue-js-是什么"><a href="#Vue-js-是什么" class="headerlink" title="Vue.js 是什么"></a>Vue.js 是什么</h3><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架</p>
<h3 id="Vue-的特点"><a href="#Vue-的特点" class="headerlink" title="Vue 的特点"></a>Vue 的特点</h3><ol>
<li>采用组件化模式，提高代码复用率、且让代码更好维护。</li>
<li>声明式编码，让编码人员无需直接操作 DOM，提高开发效率。</li>
<li>使用虛拟 DOM + Diff 算法，尽量复用 DOM 节点。</li>
</ol>
<h3 id="Vue-导入"><a href="#Vue-导入" class="headerlink" title="Vue 导入"></a>Vue 导入</h3><ul>
<li>注意: 容器和实例是一对一关系</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!DOCTYPE html&gt;<br>&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;<br>  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;<br>  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;<br>  &lt;title&gt;创建一个Vue对象&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;h1&gt;用户名是: &#123;&#123;name&#125;&#125;&lt;/h1&gt;<br>  &lt;/div&gt;<br>  &lt;script type=&quot;text/javascript&quot;&gt;<br>    //创建一个Vue对象<br>    new Vue(&#123;<br>      //指定,该对象代表&lt;div id=&quot;app&quot;&gt;,也就是说,这个div中的所有内容,都被当前的app对象管理<br>      el: &quot;#app&quot;,<br>      //定义vue中的数据<br>      data: &#123;<br>        name: &quot;张三&quot;<br>      &#125;<br>    &#125;);<br>  &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<h3 id="Vue-基本语法"><a href="#Vue-基本语法" class="headerlink" title="Vue 基本语法"></a>Vue 基本语法</h3><h4 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h4><p>插值表达式用户把 vue 中所定义的数据, 显示在页面上. 插值表达式允许用户输入”JS 表达式”<br><strong>注意区分：js 表达式 和 js 代码（语句</strong><br>表达式： a, a+b, fun() … (一个表达式会产生一个值，可以放在任何一个需要值的地方)<br>语句： if(){ } for(){ }<br><strong>Vue 模板语法包括两大类：</strong></p>
<ol>
<li>插值语法：</li>
</ol>
<ul>
<li>功能：用于解析标签体内容</li>
<li>写法：<code>&#123;&#123; xxx &#125;&#125;</code> xxx 是 js 表达式，且可以直接读取到 data 中的所有区域</li>
</ul>
<ol start="2">
<li>指令语法：</li>
</ol>
<ul>
<li>功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…）</li>
<li>举例：<code>&lt;a v-bind:href=&quot;xxx&quot;&gt;或简写为&lt;a :href=&quot;xxx&quot;&gt;</code>，xxx 同样要写 js 表达式，且可以直接读取到 data 中的所有属性<br>备注：Vue 中有很多的指令，且形式都是 v-???，此处我们只是拿 v-bind 举个例子</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;html lang=&quot;en&quot;&gt;<br><br>&lt;head&gt;<br>  &lt;meta charset=&quot;UTF-8&quot;&gt;<br>  &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;<br>  &lt;title&gt;创建一个Vue对象&lt;/title&gt;<br>&lt;/head&gt;<br><br>&lt;body&gt;<br>  &lt;div id=&quot;app&quot;&gt;<br>    &lt;h1&gt;用户名是: &#123;&#123;name&#125;&#125;&lt;/h1&gt;<br>    &lt;h1&gt;时间: &#123;&#123;Date.now()&#125;&#125;&lt;/h1&gt;<br>    &lt;a v-bind:href=&quot;url&quot;&gt;点我去博客&lt;/a&gt;<br>    &lt;a :href=&quot;url&quot;&gt;点我去博客&lt;/a&gt;<br>  &lt;/div&gt;<br>  &lt;script type=&quot;text/javascript&quot;&gt;<br>    new Vue(&#123;<br>      el: &quot;#app&quot;,<br>      data: &#123;<br>        name: &quot;你好👋&quot;,<br>        url: &quot;https://zuojiahui.fun/&quot;<br>      &#125;<br>    &#125;);<br>  &lt;/script&gt;<br>&lt;/body&gt;<br><br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>

<!-- ### 初始化脚手架

> 如果你已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，你需要先通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它。

> Vue CLI 4.x 需要 Node.js v8.9 或更高版本 (推荐 v10 以上)。你可以使用 n，nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。

#### 安装脚手架

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install -g @vue/cli<br># OR<br>yarn global add @vue/cli<br></code></pre></td></tr></table></figure>

<p>安装之后，你就可以在命令行中访问 vue 命令。你可以通过简单运行 vue，看看是否展示出了一份所有可用命令的帮助信息，来验证它是否安装成功。</p>
<p>你还可以用这个命令来检查其版本是否正确：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">vue --version<br></code></pre></td></tr></table></figure>

<h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>运行以下命令来创建一个新项目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">vue create hello-world<br></code></pre></td></tr></table></figure>

<h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><pre><code>npm run serve --&gt;
&lt;!-- ``` --&gt;
</code></pre>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>React路由的基本使用</title>
    <url>/2020/11/01/Router%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用React构建的单页面应用，要想实现页面间的跳转，首先想到的就是使用路由。在最新React中，使用的是<strong>react-router-dom</strong></p>
<h3 id="安装路由"><a href="#安装路由" class="headerlink" title="安装路由"></a>安装路由</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">npm install --save-dev react-router-dom<br></code></pre></td></tr></table></figure>
<h3 id="路由的基础配置"><a href="#路由的基础配置" class="headerlink" title="路由的基础配置"></a>路由的基础配置</h3><p><strong>第一步:</strong><br>将 <code>App.js</code> 更改成 <code>router.js</code>, 内容如下 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/*router.js 页面里的代码<br>HashRouter: 有#号<br>BrowserRouter: 没有#号<br>Route: 设置路由与组件关联<br>Switch: 只要匹配到一个地址不往下匹配，相当于for循环里面的break<br>Link: 跳转页面，相当于vue里面的router-link<br>exact: 完全匹配路由<br>Redirect: 路由重定向<br>*/<br>import React from &#x27;react&#x27;;<br>import &#123; BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;<br>//如若更换成 hash 路由模式需要将  BrowserRouter 更换为 HashRouter<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &lt;Route&gt;&lt;/Route&gt;<br>            &lt;/Switch&gt;            <br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
<p><strong>第二步:</strong><br>将入口文件<code>index.js</code>内容更改如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import ReactDOM from &#x27;react-dom&#x27;;<br>import RouterComponent from &#x27;./router&#x27;;<br>import * as serviceWorker from &#x27;./serviceWorker&#x27;;<br>function App() &#123;<br>  return (<br>    &lt;React.Fragment&gt;<br>      &lt;RouterComponent /&gt;<br>    &lt;/React.Fragment&gt;<br>  )<br>&#125;<br>ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));<br>// If you want your app to work offline and load faster, you can change<br>// unregister() to register() below. Note this comes with some pitfalls.<br>// Learn more about service workers: https://bit.ly/CRA-PWA<br>serviceWorker.unregister();<br><br></code></pre></td></tr></table></figure>
<p><strong>完成以上操作基础配置完成</strong></p>
<h3 id="路由的使用"><a href="#路由的使用" class="headerlink" title="路由的使用"></a>路由的使用</h3><p><strong>在 pages 文件夹下新建 3 页面 :</strong><br><img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/a28b18e5b30b624193e834105772ac0.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// Index文件夹下的index.js<br>import React from &#x27;react&#x27;;<br>import &#123; Link &#125; from &#x27;react-router-dom&#x27;;<br>class IndexPage extends React.Component &#123;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;首页&lt;/div&gt;<br>                &lt;ul&gt;<br>                    &lt;li&gt;&lt;Link to=&quot;/news&quot;&gt;前往新闻页面&lt;/Link&gt;&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default IndexPage<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// New文件夹下index.js<br>import React from &#x27;react&#x27;;<br>import &#123; Link &#125; from &#x27;react-router-dom&#x27;;<br>class News extends React.Component &#123;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;我是新闻页面&lt;/div&gt;<br>                &lt;ul&gt;<br>                    &lt;li&gt;&lt;Link to=&quot;/news/details&quot;&gt;新闻详情1&lt;/Link&gt;&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default News;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// New文件夹下details.js<br>import React from &#x27;react&#x27;;<br>class NewsDetails extends React.Component &#123;<br>    render() &#123;<br>        return (          <br>            &lt;React.Fragment&gt;<br>                 &lt;div&gt;新闻详情1页面&lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default NewsDetails;<br></code></pre></td></tr></table></figure>
<p><strong><code>router</code> 配置文件 <code>router.js</code>代码如下:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123;BrowserRouter as Router, Route,Switch&#125; from &#x27;react-router-dom&#x27;;<br>import IndexPage from &quot;./pages/Index&quot;;<br>import NewsPage from &#x27;./pages/News&#x27;;<br>import NewsDetails from &#x27;./pages/News/details&#x27;<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;<br>              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;<br>              &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;<br>            &lt;/Switch&gt;<br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
<p><strong>此时已经可以完成简单的路由跳转:</strong><br><img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/5ab8e180349328960ed54a43ff67140.png"></p>
<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="方法一-params"><a href="#方法一-params" class="headerlink" title="方法一 : params"></a>方法一 : params</h4><p><strong>通过<code>params</code>接受到传递过来的参数</strong><br><strong>路由表中 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123; BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;<br>import IndexPage from &quot;./pages/Index&quot;;<br>import NewsPage from &#x27;./pages/News&#x27;;<br>import NewsDetails from &#x27;./pages/News/details&#x27;<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;<br>              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;<br>              &lt;!-- 这里 id title 为需要接收的参数 --&gt;<br>              &lt;Route path=&quot;/news/details/:id/:title&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;<br>            &lt;/Switch&gt;<br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
<p><strong>Link处 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123; Link &#125; from &#x27;react-router-dom&#x27;;<br>class News extends React.Component &#123;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;我是新闻页面&lt;/div&gt;<br>                &lt;ul&gt;<br>                     &lt;!-- 1 新闻详情1为传递的参数 --&gt;<br>                    &lt;li&gt;&lt;Link to=&quot;/news/details/1/新闻详情1&quot;&gt;新闻详情1&lt;/Link&gt;&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default News;<br></code></pre></td></tr></table></figure>
<p><strong>sort页面 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class NewsDetails extends React.Component &#123;<br>    constructor(props) &#123;<br>        super(props);<br>        this.state = &#123;&#125;;<br>        console.log(&quot;id:&quot; + props.match.params.id,)<br>    &#125;<br><br>    //使用 this.props.match.params 就可以获取到传递过来的参数（ id title ）<br><br>    componentDidMount() &#123;  // 组件生命钩子函数，组件已经加载完成<br>        console.log(&quot;title:&quot; + this.props.match.params.title)<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;div&gt;新闻详情1页面&lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br>export default NewsDetails;<br></code></pre></td></tr></table></figure>
<h4 id="方法二-query"><a href="#方法二-query" class="headerlink" title="方法二 : query"></a>方法二 : query</h4><p><strong>通过<code>query</code>接受到传递过来的参数</strong><br><strong>前提：</strong>不能刷新页面,必须由其他页面跳过来，参数才会被传递过来<br><strong>注：</strong>不需要配置路由表。路由表中的内容照常<br><strong>路由表中 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123;BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;<br>import IndexPage from &quot;./pages/Index&quot;;<br>import NewsPage from &#x27;./pages/News&#x27;;<br>import NewsDetails from &#x27;./pages/News/details&#x27;<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;<br>              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;<br>              &#123;/* 不需要配置路由表,路由表中的内容照常 */&#125;<br>              &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;<br>            &lt;/Switch&gt;<br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
<p><strong>Link处 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class News extends React.Component &#123;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;我是新闻页面&lt;/div&gt;<br>                &lt;ul&gt;<br>                    &lt;li onClick=&#123;() =&gt; &#123;<br>                        this.props.history.push(&#123;<br>                            pathname: &quot;/news/details&quot;,<br>                            search:&quot;?id=1&amp;title=新闻详情1&quot;,<br>                            query: &#123;<br>                                id: 1,<br>                                title: &quot;新闻详情1&quot;<br>                            &#125;<br>                        &#125;)<br>                    &#125;&#125;&gt;新闻详情1&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default News;<br></code></pre></td></tr></table></figure>
<p><strong>sort页面 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class NewsDetails extends React.Component &#123;<br>    constructor(props) &#123;<br>        super(props);<br>        this.state = &#123;&#125;;<br>    &#125;<br>    componentDidMount() &#123;  // 组件生命钩子函数，组件已经加载完成<br>        // 使用 this.props.location.query  就可以获取到传递过来的参数（ id title ）<br>        console.log(this.props.location.query.id )<br>        console.log(this.props.location.query.title )<br>    &#125;<br>    render() &#123;<br>        return (<br>        &lt;div&gt;新闻详情1页面,id:&#123;this.props.location.query.id &#125;&lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br>export default NewsDetails;<br></code></pre></td></tr></table></figure>
<h4 id="方法三-自定义函数"><a href="#方法三-自定义函数" class="headerlink" title="方法三 : 自定义函数"></a>方法三 : 自定义函数</h4><p><strong>通过自定义函数接受到传递过来的参数</strong><br><strong>在 utils 文件夹下建立一个 js 文件，内容如下 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">export function localParam (search, hash) &#123;<br>    search = search || window.location.search;<br>    hash = hash || window.location.hash;<br>    var fn = function(str, reg) &#123;<br>        if (str) &#123;<br>            var data = &#123;&#125;;<br>            str.replace(reg, function($0, $1, $2, $3) &#123;<br>                data[$1] = $3;<br>            &#125;);<br>            return data;<br>        &#125;<br>    &#125;;<br>    return &#123;<br>            search : fn(search, new RegExp(&quot;([^?=&amp;]+)(=([^&amp;]*))?&quot;, &quot;g&quot;)) || &#123;&#125;,<br>            hash : fn(hash, new RegExp(&quot;([^#=&amp;]+)(=([^&amp;]*))?&quot;, &quot;g&quot;)) || &#123;&#125;<br>        &#125;;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>路由表中 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123;BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;<br>import IndexPage from &quot;./pages/Index&quot;;<br>import NewsPage from &#x27;./pages/News&#x27;;<br>import NewsDetails from &#x27;./pages/News/details&#x27;<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;<br>              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;<br>              &#123;/* 不需要配置路由表,路由表中的内容照常 */&#125;<br>              &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;<br>            &lt;/Switch&gt;<br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
<p><strong>Link处 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class News extends React.Component &#123;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;我是新闻页面&lt;/div&gt;<br>                &lt;ul&gt;<br>                    &lt;li onClick=&#123;() =&gt; &#123;<br>                        this.props.history.push(&quot;/news/details?id=1&amp;title=新闻详情1&quot;)<br>                    &#125;&#125;&gt;新闻详情1&lt;/li&gt;<br>                &lt;/ul&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default News;<br></code></pre></td></tr></table></figure>
<p><strong>sort页面 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>// 引入自定义方法<br>import &#123; localParam &#125; from &#x27;../../utils&#x27;<br>class NewsDetails extends React.Component &#123;<br>    constructor(props) &#123;<br>        super(props);<br>        this.state = &#123;&#125;;<br>    &#125;<br>    componentDidMount() &#123;  // 组件生命钩子函数，组件已经加载完成<br>        console.log(&quot;id ：&quot; + localParam(this.props.location.search).search.id);<br>        // 如是中文，则会出现乱码<br>        console.log(&quot;title ：&quot; + localParam(this.props.location.search).search.title) <br>        // 如果想转回中文使用 decodeURIComponent 解码<br>        console.log(&quot;title&quot; + decodeURIComponent(localParam(this.props.location.search).search.title));<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;新闻详情1页面&lt;/div&gt;<br>                &lt;ul&gt;<br>                    &lt;li&gt;&#123;localParam(this.props.location.search).search.id&#125;&lt;/li&gt;<br>                    &lt;li&gt;&#123;decodeURIComponent(localParam(this.props.location.search).search.title)&#125;&lt;/li&gt;<br>                &lt;/ul&gt;<br>                &#123;/* （-1）返回上一级路由 */&#125;<br>                &lt;button type=&#123;&quot;button&quot;&#125; onClick=&#123;() =&gt; &#123; this.props.history.go(-1) &#125;&#125;&gt;返回&lt;/button&gt;<br>            &lt;/React.Fragment&gt;<br><br>        )<br>    &#125;<br>&#125;<br>export default NewsDetails;<br></code></pre></td></tr></table></figure>
<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><h4 id="方法一-自定义组件"><a href="#方法一-自定义组件" class="headerlink" title="方法一 : 自定义组件"></a>方法一 : 自定义组件</h4><p><strong>制作异步函数组件</strong><br><strong>建立AsynComponent.js文件，内容如下：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Component &#125; from &quot;react&quot;;<br>export default function asyncComponent(importComponent) &#123;<br>    class AsyncComponent extends Component &#123;<br>        constructor(props) &#123;<br>            super(props);<br><br>            this.state = &#123;<br>                component: null<br>            &#125;;<br>        &#125;<br>        async componentDidMount() &#123;<br>            const &#123; default: component &#125; = await importComponent();<br>            this.setState(&#123;<br>                component: component<br>            &#125;);<br>        &#125;<br>        render() &#123;<br>            const C = this.state.component;<br>            return C ? &lt;C &#123;...this.props&#125; /&gt; : null;<br>        &#125;<br>    &#125;<br>    return AsyncComponent;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>路由表中 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123;BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;<br>import asyncComponent from &#x27;./assets/components/async/asyncComponent&#x27;;  // 引入懒加载组件<br>// 激活chunkFilename,默认不激活(路由懒加载)<br>const  IndexPage = asyncComponent(() =&gt;import(&quot;./pages/Index&quot;));<br>const  NewsPage = asyncComponent(() =&gt;import(&quot;./pages/News&quot;));<br>const  NewsDetails = asyncComponent(() =&gt;import(&quot;./pages/News/details&quot;));<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;<br>              &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;<br>              &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;<br>            &lt;/Switch&gt;<br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
<h4 id="方法二-lazy和suspense"><a href="#方法二-lazy和suspense" class="headerlink" title="方法二 : lazy和suspense"></a>方法二 : lazy和suspense</h4><p><strong>路由表中 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; lazy, Suspense &#125; from &#x27;react&#x27;;      //导入 lazy, Suspense <br>import &#123; BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;<br>const IndexPage = lazy(() =&gt; import(&quot;./pages/Index&quot;));<br>const NewsPage = lazy(() =&gt; import(&quot;./pages/News&quot;));<br>const NewsDetails = lazy(() =&gt; import(&quot;./pages/News/details&quot;));<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &#123;/* 用 Suspense 包裹 Route */&#125;<br>              &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;<br>                &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;<br>                &lt;Route path=&quot;/news&quot; exact component=&#123;NewsPage&#125;&gt;&lt;/Route&gt;<br>                &lt;Route path=&quot;/news/details&quot; exact component=&#123;NewsDetails&#125;&gt;&lt;/Route&gt;<br>              &lt;/Suspense&gt;<br>            &lt;/Switch&gt;<br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
<h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><h4 id="路由嵌套-主子路由"><a href="#路由嵌套-主子路由" class="headerlink" title="路由嵌套(主子路由)"></a>路由嵌套(主子路由)</h4><p><strong>路由表中 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; lazy, Suspense &#125; from &#x27;react&#x27;;<br>import &#123; BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;<br>const IndexPage = lazy(() =&gt; import(&quot;./pages/Index&quot;));<br>const GoodssPage = lazy(() =&gt; import(&quot;./pages/Home&quot;));<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;<br>                &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;<br>                &#123;/* 这里不需要添加 exact */&#125;<br>                &lt;Route path=&quot;/goods&quot; component=&#123;GoodssPage&#125;&gt;&lt;/Route&gt;<br>              &lt;/Suspense&gt;<br>            &lt;/Switch&gt;<br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
<p><strong>sort页面 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; lazy, Suspense &#125; from &#x27;react&#x27;;<br>import &#123; Route, Switch, Redirect &#125; from &#x27;react-router-dom&#x27;;<br>const GoodsItem = lazy(() =&gt; import(&quot;./item&quot;))<br>const GoodsDetails = lazy(() =&gt; import(&quot;./details&quot;))<br>const GoodsEvaluation = lazy(() =&gt; import(&quot;./evaluation&quot;))<br>class Index extends React.Component &#123;<br>    goPage(url) &#123;<br>        // 这里使用 replace 方法，不采用 push<br>        this.props.history.replace(url);<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;ul&gt;<br>                    &lt;li onClick=&#123;this.goPage.bind(this, &#x27;/goods/item&#x27;)&#125;&gt;商品&lt;/li&gt;<br>                    &lt;li onClick=&#123;this.goPage.bind(this, &#x27;/goods/details&#x27;)&#125;&gt;详情&lt;/li&gt;<br>                    &lt;li onClick=&#123;this.goPage.bind(this, &#x27;/goods/evaluation&#x27;)&#125;&gt;评价&lt;/li&gt;<br>                &lt;/ul&gt;<br>                &lt;button type=&quot;button&quot; onClick=&#123;this.props.history.go.bind(this, -1)&#125;&gt;返回&lt;/button&gt;<br>                &lt;div&gt;<br>                    &lt;Switch&gt;<br>                        &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;<br>                            &#123;/* 这里不需要添加 exact */&#125;<br>                            &lt;Route path=&quot;/goods/item&quot; component=&#123;GoodsItem&#125;&gt;&lt;/Route&gt;<br>                            &lt;Route path=&quot;/goods/details&quot; component=&#123;GoodsDetails&#125;&gt;&lt;/Route&gt;<br>                            &lt;Route path=&quot;/goods/evaluation&quot; component=&#123;GoodsEvaluation&#125;&gt;&lt;/Route&gt;<br>                            &#123;/* 路由重定向 : 需要要放在最下面 ，先有 path*/&#125;<br>                            &lt;Redirect to=&quot;/goods/item&quot;&gt;&lt;/Redirect&gt;<br>                        &lt;/Suspense&gt;<br>                    &lt;/Switch&gt;<br>                &lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default Index;<br></code></pre></td></tr></table></figure>
<h4 id="子组件路由跳转"><a href="#子组件路由跳转" class="headerlink" title="子组件路由跳转"></a>子组件路由跳转</h4><p><strong>withRouter实现子组件路由跳转</strong><br><strong>sort页面 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; lazy, Suspense &#125; from &#x27;react&#x27;;<br>import &#123; Route, Switch, Redirect &#125; from &#x27;react-router-dom&#x27;;<br>import GoodsNav from &quot;../../assets/components/GoodsNav&quot;      //引入 GoodsNav 组件<br>const GoodsItem = lazy(() =&gt; import(&quot;./item&quot;))<br>const GoodsDetails = lazy(() =&gt; import(&quot;./details&quot;))<br>const GoodsEvaluation = lazy(() =&gt; import(&quot;./evaluation&quot;))<br>class Index extends React.Component &#123;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &#123;/* GoodsNav子组件 */&#125;<br>                &lt;GoodsNav&gt;&lt;/GoodsNav&gt;<br>                &lt;button type=&quot;button&quot; onClick=&#123;this.props.history.go.bind(this, -1)&#125;&gt;返回&lt;/button&gt;<br>                &lt;div&gt;<br>                    &lt;Switch&gt;<br>                        &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;<br>                            &#123;/* 这里不需要添加 exact */&#125;<br>                            &lt;Route path=&quot;/goods/item&quot; component=&#123;GoodsItem&#125;&gt;&lt;/Route&gt;<br>                            &lt;Route path=&quot;/goods/details&quot; component=&#123;GoodsDetails&#125;&gt;&lt;/Route&gt;<br>                            &lt;Route path=&quot;/goods/evaluation&quot; component=&#123;GoodsEvaluation&#125;&gt;&lt;/Route&gt;<br>                            &#123;/* 路由重定向 : 需要要放在最下面 ，先有 path*/&#125;<br>                            &lt;Redirect to=&quot;/goods/item&quot;&gt;&lt;/Redirect&gt;<br>                        &lt;/Suspense&gt;<br>                    &lt;/Switch&gt;<br>                &lt;/div&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default Index;<br></code></pre></td></tr></table></figure>


<p><strong>新建一个GoodsNav组件 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123; withRouter &#125; from &#x27;react-router-dom&#x27;    //引入 withRouter<br>function GoodsNav(props) &#123;<br>    const goPage = (url) =&gt; &#123; <br>        console.log(this,props,url)   //这里没有 this : undefined<br>        props.history.replace(url)<br>    &#125;;<br>    return (<br>        &lt;ul&gt;<br>            &lt;li onClick=&#123;goPage.bind(null, &#x27;/goods/item&#x27;)&#125;&gt;商品&lt;/li&gt;<br>            &lt;li onClick=&#123;goPage.bind(null, &#x27;/goods/details&#x27;)&#125;&gt;详情&lt;/li&gt;<br>            &lt;li onClick=&#123;goPage.bind(null, &#x27;/goods/evaluation&#x27;)&#125;&gt;评价&lt;/li&gt;<br>        &lt;/ul&gt;<br>    )<br>&#125;<br>export default withRouter(GoodsNav);<br></code></pre></td></tr></table></figure>
<h3 id="路由认证"><a href="#路由认证" class="headerlink" title="路由认证"></a>路由认证</h3><p><strong>制作会员认证路由 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//在routes/private.js里面的代码<br>import React from &#x27;react&#x27;;<br>import &#123;Route,Redirect&#125; from &#x27;react-router-dom&#x27;;<br>export function AuthRoute(&#123; component:Component, ...rest &#125;) &#123;<br>    return (<br>        &lt;Route &#123;...rest&#125; render=&#123;props =&gt;<br>                Boolean(localStorage[&#x27;isLogin&#x27;]) ? (<br>                    &lt;Component &#123;...props&#125; /&gt;<br>                ) : (<br>                    &lt;Redirect<br>                        to=&#123;&#123;<br>                            pathname: &quot;/login&quot;,<br>                            state: &#123; from: props.location &#125;<br>                        &#125;&#125;<br>                    /&gt;<br>                )<br>            &#125;<br>        /&gt;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>建立首页 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>import &#123;Link&#125; from &#x27;react-router-dom&#x27;;<br>class IndexPage extends React.Component&#123;<br>    render() &#123;<br>        return(<br>            &lt;React.Fragment&gt;<br>                &lt;div&gt;首页&lt;/div&gt;<br>                &lt;ul&gt;<br>                    &lt;li&gt;&lt;Link to=&quot;/login&quot;&gt;会员登录&lt;/Link&gt;&lt;/li&gt;<br>                    &lt;li&gt;&lt;Link to=&quot;/user&quot;&gt;会员中心&lt;/Link&gt;&lt;/li&gt;<br>                &lt;/ul&gt;<br><br>            &lt;/React.Fragment&gt;<br>            <br>        )<br>    &#125;<br>&#125;<br>export default IndexPage<br></code></pre></td></tr></table></figure>
<p><strong>建立会员登录 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class Login extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state=&#123;<br>            username: &quot;&quot;,<br>            password: &quot;&quot;,<br>        &#125;<br>    &#125;<br>    doLogin() &#123;<br>        if(this.state.username.match(/^\s*$/)) &#123;<br>            alert(&quot;请输入用户名&quot;);<br>            return;<br>        &#125;<br>        if(this.state.password.match(/^\s*$/)) &#123;<br>            alert(&quot;请输入用密码&quot;);<br>            return;<br>        &#125;<br>        // 登录成功将username进行存储，并返回上级<br>        localStorage[&#x27;username&#x27;] = this.state.username;<br>        localStorage[&#x27;isLogin&#x27;] = true;<br>        this.props.history.go(-1);<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                     &lt;div&gt;<br>                         用户名 : &lt;input type=&quot;text&quot; placeholder=&quot;请输入用户名&quot; onClick=&#123;(e)=&gt;&#123;<br>                             this.setState(&#123;username : e.target.value&#125;)<br>                         &#125;&#125;/&gt;<br>                         &lt;br/&gt;<br>                         密码 : &lt;input type=&quot;text&quot; placeholder=&quot;请输入密码&quot; onClick=&#123;(e)=&gt;&#123;<br>                             this.setState(&#123;password: e.target.value&#125;)<br>                         &#125;&#125;/&gt;<br>                     &lt;/div&gt;<br>                     &lt;button type=&quot;button&quot; onClick=&#123;this.doLogin.bind(this)&#125;&gt;登录&lt;/button&gt;<br>            &lt;/React.Fragment&gt;<br>       <br>        )<br>    &#125;<br>&#125;<br>export default Login;<br></code></pre></td></tr></table></figure>
<p><strong>建立会员中心页面 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React from &#x27;react&#x27;;<br>class User extends React.Component &#123;<br>    outLogin() &#123;<br>        // 退出清空数据<br>        localStorage.clear();<br>        this.props.history.replace(&quot;/login&quot;)<br>    &#125;<br>    render() &#123;<br>        return(<br>            &lt;React.Fragment&gt;<br>            &lt;div&gt;欢迎&#123;localStorage[&#x27;username&#x27;]&#125; 回来！&lt;/div&gt;<br>            &lt;button type=&quot;button&quot; onClick=&#123;this.outLogin.bind(this)&#125;&gt;安全退出&lt;/button&gt;<br>     <br>            &lt;/React.Fragment&gt;<br>   )<br>    &#125;<br>&#125;<br>export default User;<br></code></pre></td></tr></table></figure>
<p><strong>路由表中 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; lazy, Suspense &#125; from &#x27;react&#x27;;<br>import &#123; BrowserRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;;<br>// 引入路由认证 js <br>import &#123; AuthRoute &#125; from &quot;./utils/router/private&quot;<br>const IndexPage = lazy(() =&gt; import(&quot;./pages/Index&quot;));<br>const LoginPage = lazy(() =&gt; import(&quot;./pages/login&quot;));<br>const UserPage = lazy(() =&gt; import(&quot;./pages/user&quot;));<br>class RouterComponent extends React.Component &#123;<br>  render() &#123;<br>    return (<br>      &lt;React.Fragment&gt;<br>        &lt;Router&gt;<br>          &lt;React.Fragment&gt;<br>            &lt;Switch&gt;<br>              &lt;Suspense fallback=&#123;&lt;React.Fragment /&gt;&#125;&gt;<br>                &lt;Route path=&quot;/&quot; exact component=&#123;IndexPage&#125;&gt;&lt;/Route&gt;<br>                &lt;Route path=&quot;/login&quot; exact component=&#123;LoginPage&#125;&gt;&lt;/Route&gt;<br>                &#123;/* 将 Route 更换成 AuthRoute*/&#125;<br>                &lt;AuthRoute path=&quot;/user&quot; exact component=&#123;UserPage&#125;&gt;&lt;/AuthRoute&gt;<br>              &lt;/Suspense&gt;<br>            &lt;/Switch&gt;<br>          &lt;/React.Fragment&gt;<br>        &lt;/Router&gt;<br>      &lt;/React.Fragment&gt;<br>    )<br>  &#125;<br>&#125;<br>export default RouterComponent;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title>将数组转换为数组对象</title>
    <url>/2023/03/13/%E5%B0%86%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E6%88%90%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际开发中，我们经常需要对数据进行相应的处理，以便使用，这篇文章主要讲述如何将数组转换为数组对象格式</p>
<blockquote>
<p>原始数据：  [“苹果”, “西瓜”, “香蕉”, “梨子”]</p>
</blockquote>
<blockquote>
<p>需要转换为的数据： [{…}, {…}, {…}, {…}]<br>0: {id: 0, name: “苹果”}<br>1: {id: 1, name: “西瓜”}<br>2: {id: 2, name: “香蕉”}<br>3: {id: 3, name: “梨子”}</p>
</blockquote>
<blockquote>
<p>id，name可根据具体需求修改</p>
</blockquote>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;苹果&quot;, &quot;西瓜&quot;, &quot;香蕉&quot;, &quot;梨子&quot;];<br>let obj = &#123;&#125;;<br>// 将数组转化为对象<br>for (let key in arr) &#123;<br>  obj[key] = arr[key];<br>&#125;<br>newObj = Object.keys(obj).map((val) =&gt; (&#123;<br>  id: val,<br>  name: obj[val],<br>&#125;));<br>console.log(newObj);<br></code></pre></td></tr></table></figure>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [&quot;苹果&quot;, &quot;西瓜&quot;, &quot;香蕉&quot;, &quot;梨子&quot;];<br>let newArr = []<br>for(let i = 0, len = arr.length; i &lt; len; i++) &#123;<br>  let obj = &#123;&#125;;<br>  obj.id = i;<br>  obj.name = arr[i];<br>  newArr.push(obj)<br>&#125;<br>console.log(newArr)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组对象</tag>
      </tags>
  </entry>
  <entry>
    <title>前端</title>
    <url>/2023/03/13/%E5%89%8D%E7%AB%AF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<!-- ### 前言
由于前端知识点太多就很复杂，面试的时候有很多面试官又经常问一些偏基础的技术点，故整理此文章来帮助大家更高的应对面试，也以备自己不时之需 -->

<h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><h4 id="Javascript-三大部分"><a href="#Javascript-三大部分" class="headerlink" title="Javascript 三大部分"></a>Javascript 三大部分</h4><ol>
<li>ECMAScript (JS 的语法和基本对象)</li>
<li>DOM (文档对象模型:处理网页内容的方法和接口)</li>
<li>BOM (浏览器对象模型:与浏览器交互的方法和接口)</li>
</ol>
<h4 id="Javascript-特点"><a href="#Javascript-特点" class="headerlink" title="Javascript 特点"></a>Javascript 特点</h4><p><code>解释性语言</code>:语言分为两种</p>
<ol>
<li><p>解释性语言：翻译一行执行一行，不会生成文件<br>优点：可以跨平台（windows linux ）<br>缺点：编译稍微慢</p>
</li>
<li><p>编译性语言：翻译过程为通篇翻译，看完一行，看完第二行，看完全部，生成翻译完的文件，并且执行翻译完的文件（ 列如 C C++ ）<br>优点：编译快<br>缺点：不可以跨平台</p>
</li>
</ol>
<p><code>单线程</code>:线程分为两种</p>
<ol>
<li>单线程（同步）：同一时间只能做一件事</li>
<li>多线程（异步）：同一时间做多件事</li>
</ol>
<h4 id="数据类型-—-值类型（分为两类）"><a href="#数据类型-—-值类型（分为两类）" class="headerlink" title="数据类型 —- 值类型（分为两类）"></a>数据类型 —- 值类型（分为两类）</h4><p><code>栈数据（原始值，基本数据类型）</code>：Number &emsp; String &emsp; Boolean &emsp; undefined &emsp; null &emsp; (五大类)<br>原始值存在栈里面：简单数据类型的值是储存在栈中，当把一个变量传递给另一个变量时，是把一个栈中的东西复制到另一个到栈中，并且这两个变量互不影响，修改其中的变量值时，不会改变另外一个变量的结果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var a = 1;<br>var b = a;<br>a = 2;<br>console.log(a);   //2<br>console.log(b);   //1<br></code></pre></td></tr></table></figure>

<p><code>堆数据（引用值）</code>: array &emsp; object &emsp; function …..<br>引用值大致存在堆里面：引用值（复杂数据类型）是把引用变量的名称（内存地址）存储在栈中，但是把其实际对象存储在堆中，栈中的内存地址指向堆中的实际对象，当把引用对象传递给另一个变量时，复制的其实是指向实际对象的指针（内存地址），此时两者指向的是同一个数据，若通过方法改变其中一个变量的值，则访问另一个变量时，其值也会跟着改变，  因为 JavaScript 中对象的赋值是默认引用赋值的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var a = [1];<br>var b = a;<br>a.push(2);<br>console.log(a);   //[1, 2]<br>console.log(b);   //[1, 2]<br></code></pre></td></tr></table></figure>

<h4 id="null-和-undefined-的区别"><a href="#null-和-undefined-的区别" class="headerlink" title="null 和 undefined 的区别"></a>null 和 undefined 的区别</h4><p>在一些情况下，null 和 undefined 几乎是一样的。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">if (!undefined) &#123;// undefined is false<br>    console.log(&#x27;undefined is false&#x27;);<br>&#125;<br><br>if (!null) &#123;// null is false<br>    console.log(&#x27;null is false&#x27;);<br>&#125;<br><br>if(undefined == null) &#123;// true<br>    console.log(&#x27;undefined == null&#x27;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>但是 null 和 undefined 仍然存在一些区别：</strong> 1.类型不一样<br>null 是一个 object！所以，我们可以这么理解，null 是一个对象的占位符，表示这个对象还未初始化，是个”空对象”；而 undefined 表示压根没人对这个变量做定义，没人知道这到底是个什么玩意儿。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">console.log(typeof undefined); //undefined<br>console.log(typeof null); //object<br></code></pre></td></tr></table></figure>

<p>2.转为数值时，值不一样<br>undefined 转为数值 NaN，null 转为数值 0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">console.log(Number(undefined)); //NaN<br>console.log(undefined + 10);//NaN<br><br>console.log(Number(null)); //0<br>console.log(null + 10); //10<br></code></pre></td></tr></table></figure>

<p><strong>null 的典型用法</strong><br>（1） 作为函数的参数，表示该函数的参数不是对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function testObj(obj) &#123;<br>    if(null == obj) &#123;<br>        // 异常处理,比如创造一个新对象<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2） 作为对象原型链的终点。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Object.getPrototypeOf(Object.prototype)<br>// null<br></code></pre></td></tr></table></figure>

<p><strong>undefined 的典型用法</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">// (1)变量被声明了，但没有赋值时，就等于undefined。<br>var i;<br>i // undefined<br><br>//（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>function f(x) &#123;<br>    console.log(x)<br>&#125;<br>f() // undefined<br><br>// (3)对象没有赋值的属性，该属性的值为undefined。<br>var  o = new Object();<br>o.p // undefined<br><br>//（4）函数没有返回值时，默认返回undefined。<br>var x = f();<br>x // undefined<br></code></pre></td></tr></table></figure>

<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>优先级&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;运算符&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;顺序&emsp;&emsp;&emsp;<br>&emsp;1&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 小括号&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ()<br>&emsp;2&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 一元运算符&emsp;&emsp;&emsp;&emsp;&emsp; ++ &emsp; – &emsp; ！<br>&emsp;3&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 算术运算符&emsp;&emsp;&emsp;&emsp;&emsp; 先&emsp; * / % &emsp;后&emsp; + -<br>&emsp;4&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 比较运算符&emsp;&emsp;&emsp;&emsp;&emsp; &gt; &emsp; &gt;=&emsp; &lt;&emsp; &lt;=<br>&emsp;5&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 相等运算符&emsp;&emsp;&emsp;&emsp;&emsp; == &emsp; !=&emsp; ===&emsp; !==&emsp;<br>&emsp;6&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 逻辑运算符&emsp;&emsp;&emsp;&emsp;&emsp; 先 &emsp; &amp;&amp; &emsp;后 &emsp; ||<br>&emsp;7&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; 赋值运算符&emsp;&emsp;&emsp;&emsp;&emsp; =</p>
<h4 id="与-或-非-逻辑运算符"><a href="#与-或-非-逻辑运算符" class="headerlink" title="与 或 非(逻辑运算符)"></a>与 或 非(逻辑运算符)</h4><p>用来进行布尔值运算的运算符，其返回值也是布尔值（后续开发中常用于多个条件判断）<br>underfined &emsp;&emsp;&emsp;&emsp; null &emsp;&emsp;&emsp; &emsp; NaN &emsp;&emsp;&emsp; “” &emsp;&emsp;&emsp;&emsp; 0 &emsp;&emsp;&emsp;&emsp; false<br><strong>&amp;&amp; ( 与 )——短路语句</strong><br>如果表达示为假，则会返回假的第一个假值，如果表达式都为真，则会返回最后那个真值（ 碰到假就会返回该值 ）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var  a  =  1  &amp;&amp;  2  &amp;&amp;  3;                    //3<br>var  a  =  1  &amp;&amp;  0  &amp;&amp;  3;                    //0<br><br>//短路作用 ：确保代码能够正常执行，常用于后端获取数据后进行判断<br>if(data &amp;&amp; data.下面的某个属性) &#123;<br>    ...执行代码段<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>|| ( 或 )——兼容语句</strong><br>如果表达式为真，则会返回第一个真值，如果表达式都为假，则会返回最后那个假值（碰到真就会返回该值）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var  a  =  2  ||  3；                           //2<br>var  a  =  2  ||  0  ||  3 ；                   //2<br>var  a  =  0  ||  false ；                      //false<br><br>//兼容作用 ：常用于确保代码能够多条件执行<br>var event  =  e  ||  window.event;<br></code></pre></td></tr></table></figure>

<p><strong>！(非)—–取反符</strong><br>用来取布尔值在取反</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var  a  =  !&quot;&quot;;                                //true<br>var  a  =  !123;                               //fals<br><br>var obj = &#123;id:1, name:&quot;marry&quot;&#125;<br>    if(!!obj || id !==&quot;&quot;) &#123;<br>     console.log(obj.name)<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>小星星特效</title>
    <url>/2023/03/13/%E9%BC%A0%E6%A0%87%E7%BB%8F%E8%BF%87%E5%B0%8F%E6%98%9F%E6%98%9F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这是使用原生 JS 实现的一款鼠标经过特效，实现效果如下图</p>
<h3 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h3><div  align="center">    
<img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/屏幕截图 2020-12-20 185425.jpg" width = 50% height = 50% />
</div> 

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;script&gt;<br>  //鼠标经过小星星特效<br>  (function fairyDustCursor() &#123;<br>    var possibleColors = [&quot;#D61C59&quot;, &quot;#E7D84B&quot;, &quot;#1B8798&quot;];<br>    var width = window.innerWidth;<br>    var height = window.innerHeight;<br>    var cursor = &#123; x: width / 2, y: width / 2 &#125;;<br>    var particles = [];<br><br>    function init() &#123;<br>      bindEvents();<br>      loop();<br>    &#125;<br><br>    // Bind events that are needed<br>    function bindEvents() &#123;<br>      document.addEventListener(&quot;mousemove&quot;, onMouseMove);<br>      document.addEventListener(&quot;touchmove&quot;, onTouchMove);<br>      document.addEventListener(&quot;touchstart&quot;, onTouchMove);<br><br>      window.addEventListener(&quot;resize&quot;, onWindowResize);<br>    &#125;<br><br>    function onWindowResize(e) &#123;<br>      width = window.innerWidth;<br>      height = window.innerHeight;<br>    &#125;<br><br>    function onTouchMove(e) &#123;<br>      if (e.touches.length &gt; 0) &#123;<br>        for (var i = 0; i &lt; e.touches.length; i++) &#123;<br>          addParticle(<br>            e.touches[i].clientX,<br>            e.touches[i].clientY,<br>            possibleColors[<br>              Math.floor(Math.random() * possibleColors.length)<br>            ]<br>          );<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    function onMouseMove(e) &#123;<br>      cursor.x = e.clientX;<br>      cursor.y = e.clientY;<br><br>      addParticle(<br>        cursor.x,<br>        cursor.y,<br>        possibleColors[Math.floor(Math.random() * possibleColors.length)]<br>      );<br>    &#125;<br><br>    function addParticle(x, y, color) &#123;<br>      var particle = new Particle();<br>      particle.init(x, y, color);<br>      particles.push(particle);<br>    &#125;<br><br>    function updateParticles() &#123;<br>      // Updated<br>      for (var i = 0; i &lt; particles.length; i++) &#123;<br>        particles[i].update();<br>      &#125;<br><br>      // Remove dead particles<br>      for (var i = particles.length - 1; i &gt;= 0; i--) &#123;<br>        if (particles[i].lifeSpan &lt; 0) &#123;<br>          particles[i].die();<br>          particles.splice(i, 1);<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    function loop() &#123;<br>      requestAnimationFrame(loop);<br>      updateParticles();<br>    &#125;<br><br>    /**<br>     * Particles<br>     */<br><br>    function Particle() &#123;<br>      this.character = &quot;*&quot;;<br>      this.lifeSpan = 120; //ms<br>      this.initialStyles = &#123;<br>        position: &quot;fixed&quot;,<br>        top: &quot;0&quot;, //必须加<br>        display: &quot;block&quot;,<br>        pointerEvents: &quot;none&quot;,<br>        &quot;z-index&quot;: &quot;10000000&quot;,<br>        fontSize: &quot;20px&quot;,<br>        &quot;will-change&quot;: &quot;transform&quot;,<br>      &#125;;<br><br>      // Init, and set properties<br>      this.init = function (x, y, color) &#123;<br>        this.velocity = &#123;<br>          x: (Math.random() &lt; 0.5 ? -1 : 1) * (Math.random() / 2),<br>          y: 1,<br>        &#125;;<br><br>        this.position = &#123; x: x - 10, y: y - 20 &#125;;<br>        this.initialStyles.color = color;<br>        this.element = document.createElement(&quot;span&quot;);<br>        this.element.innerHTML = this.character;<br>        applyProperties(this.element, this.initialStyles);<br>        this.update();<br><br>        document.body.appendChild(this.element);<br>      &#125;;<br><br>      this.update = function () &#123;<br>        this.position.x += this.velocity.x;<br>        this.position.y += this.velocity.y;<br>        this.lifeSpan--;<br><br>        this.element.style.transform =<br>          &quot;translate3d(&quot; +<br>          this.position.x +<br>          &quot;px,&quot; +<br>          this.position.y +<br>          &quot;px,0) scale(&quot; +<br>          this.lifeSpan / 120 +<br>          &quot;)&quot;;<br>      &#125;;<br><br>      this.die = function () &#123;<br>        this.element.parentNode.removeChild(this.element);<br>      &#125;;<br>    &#125;<br><br>    /**<br>     * Utils<br>     */<br><br>    // Applies css `properties` to an element.<br>    function applyProperties(target, properties) &#123;<br>      for (var key in properties) &#123;<br>        target.style[key] = properties[key];<br>      &#125;<br>    &#125;<br><br>    init();<br>  &#125;)();<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>炫酷特效</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>数组去重的几种常见写法</title>
    <url>/2023/03/13/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E5%86%99%E6%B3%95/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在实际工作或面试中，我们经常会遇到“数组去重”问题，以下来是总结的一些实现的数组去重的多种方法</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>使用双层循环改变原数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 1, 2, 6, 6, 6, 6];<br>function norepeat(arr) &#123;<br>  for (var i = 0; i &lt; arr.length; i++) &#123;<br>    for (var j = 0; j &lt; arr.length; j++) &#123;<br>      if (arr[i] == arr[j] &amp;&amp; i != j) &#123;<br>        arr.splice(j, 1);<br>      &#125;<br>    &#125;<br>  &#125;<br>  return arr;<br>&#125;<br>var arr2 = norepeat(arr);<br>console.log(arr2);      //[1, 2, 3, 4, 5, 6]<br>console.log(arr)        //[1, 2, 3, 4, 5, 6]<br></code></pre></td></tr></table></figure>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>使用 es6 中Set方法，此方法最为简便</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">let arr = [1, 4, 3, 6, 3, 4, 5, 7, 6, 2];<br>//写法一<br>let set = new Set(arr);<br>let arr1 = Array.from(set); // Array.from方法可以将 Set 结构转为数组。<br>// 写法二<br>let arr2 = [...new Set(arr)]<br>console.log(arr1);      //[ 1, 2, 4, 3, 6 ]<br>console.log(arr2);      //[1, 4, 3, 6, 5, 7, 2]<br>console.log(arr);       //[1, 4, 3, 6, 3, 4, 5, 7, 6, 2]<br></code></pre></td></tr></table></figure>
<h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>将数组的每一个元素依次与其他元素做比较，发现重复元素，利用数组方法splice()删除重复元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5, 5];<br>function norepeat(arr) &#123;<br>  for (var i = 0; i &lt; arr.length - 1; i++) &#123;<br>    for (var j = i + 1; j &lt; arr.length; j++) &#123;<br>      if (arr[i] == arr[j]) &#123;<br>        arr.splice(j, 1);<br>        j--;<br>      &#125;<br>    &#125;<br>  &#125;<br>  return arr;<br>&#125;<br>var arr2 = norepeat(arr);<br>console.log(arr2);         //[1, 23, 3, 5, 6, 7, 9, 8]<br>console.log(arr);          //[1, 23, 3, 5, 6, 7, 9, 8]<br></code></pre></td></tr></table></figure>
<h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><p>借助新数组，判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中（原数组长度不变但被按字符串顺序排序）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];<br>function norepeat(arr) &#123;<br>  var temp = [];<br>  var end; //临时变量用于对比重复元素<br>  arr.sort();<br>  end = arr[0];<br>  temp.push(arr[0]);<br>  for (var i = 1; i &lt; arr.length; i++) &#123;<br>    if (arr[i] != end) &#123;<br>      //当前元素如果和临时元素不等则将此元素添加到新数组中<br>      temp.push(arr[i]);<br>      end = arr[i];<br>    &#125;<br>  &#125;<br>  return temp;<br>&#125;<br>var arr2 = norepeat(arr);<br>console.log(arr2);       //[1, 23, 3, 5, 6, 7, 8, 9]<br>console.log(arr);        //[1, 1, 1, 1, 23, 23, 3, 5, 5, 6, 7, 8, 9, 9]<br></code></pre></td></tr></table></figure>
<h3 id="方法五"><a href="#方法五" class="headerlink" title="方法五"></a>方法五</h3><p>创建一个新数组，判断新数组中是否存在该元素如果不存在则将此元素添加到新数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];<br>function norepeat(arr) &#123;<br>  var temp = [];<br>  for (var i = 0; i &lt; arr.length; i++) &#123;<br>    if (temp.indexOf(arr[i]) == -1) &#123;<br>      temp.push(arr[i]);<br>    &#125;<br>  &#125;<br>  return temp;<br>&#125;<br>var arr2 = norepeat(arr);<br>console.log(arr2);      //[1, 23, 3, 5, 6, 7, 9, 8]<br>console.log(arr);       //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5]<br></code></pre></td></tr></table></figure>
<h3 id="方法六"><a href="#方法六" class="headerlink" title="方法六"></a>方法六</h3><p>借助indexOf()方法判断此元素在该数组中首次出现的位置下标与循环的下标是否相等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];<br>function norepeat(arr) &#123;<br>  for (var i = 0; i &lt; arr.length; i++) &#123;<br>    if (arr.indexOf(arr[i]) != i) &#123;<br>      arr.splice(i, 1); //删除数组元素后数组长度减1后面的元素前移<br>      i--; //数组下标回退<br>    &#125;<br>  &#125;<br>  return arr;<br>&#125;<br>var arr2 = norepeat(arr);<br>console.log(arr2);      //[1, 23, 3, 5, 6, 7, 9, 8]<br>console.log(arr);       //[1, 23, 3, 5, 6, 7, 9, 8]<br></code></pre></td></tr></table></figure>
<h3 id="方法七"><a href="#方法七" class="headerlink" title="方法七"></a>方法七</h3><p>创建一个新数组 通过indexOf方判断当前元素在数组中的索引如果与循环的下标相等则添加到新数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];<br>function norepeat(arr) &#123;<br>  var temp = [];<br>  for (var i = 0; i &lt; arr.length; i++) &#123;<br>    if (arr.indexOf(arr[i]) == i) &#123;<br>      temp.push(arr[i]);<br>    &#125;<br>  &#125;<br>  return temp;<br>&#125;<br>var arr2 = norepeat(arr);<br>console.log(arr2);     //[1, 23, 3, 5, 6, 7, 9, 8]<br>console.log(arr);      //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5]<br></code></pre></td></tr></table></figure>
<h3 id="方法八"><a href="#方法八" class="headerlink" title="方法八"></a>方法八</h3><p>利用数组中的filter方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 4, 2, 2, 3, 1, 3, 4, 5, 6, 6, 8, 9];<br>var arr2 = arr.filter(function (value, index, self) &#123;<br>  return self.indexOf(value) === index;<br>&#125;);<br>console.log(arr2);    //[1, 4, 2, 3, 5, 6, 8, 9]<br>console.log(arr);     //[1, 4, 2, 2, 3, 1, 3, 4, 5, 6, 6, 8, 9]<br></code></pre></td></tr></table></figure>
<h3 id="方法九"><a href="#方法九" class="headerlink" title="方法九"></a>方法九</h3><p>利用空对象来记录新数组中已经存储过的元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5];<br>var obj = &#123;&#125;;<br>var arr2 = [];<br>for (var i = 0; i &lt; arr.length; i++) &#123;<br>  if (!obj[arr[i]]) &#123;<br>    obj[arr[i]] = true;<br>    arr2.push(arr[i]);<br>  &#125;<br>&#125;<br>console.log(arr2);    //[1, 23, 3, 5, 6, 7, 9, 8]<br>console.log(arr);     //[1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5, 5, 5]<br></code></pre></td></tr></table></figure>
<h3 id="方法十"><a href="#方法十" class="headerlink" title="方法十"></a>方法十</h3><p>借助两个新数组</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 2, 1, 1, 1];<br>var arr2 = [];<br>for (var i = 0; i &lt; arr.length; i++) &#123;<br>  var arr3 = []; //接收重复数据后面的下标<br>  //内层循环找出有重复数据的下标<br>  for (var j = i + 1; j &lt; arr.length; j++) &#123;<br>    if (arr[i] == arr[j]) &#123;<br>      arr3.push(j); //找出后面重复数据的下标<br>    &#125;<br>  &#125;<br>  // console.log(arr3);<br>  if (arr3.length == 0) &#123;<br>    //若重复数组没有值说明其不是重复数据<br>    arr2.push(arr[i]);<br>  &#125;<br>&#125;<br>console.log(arr2);     //[5, 4, 3, 2, 1]<br>console.log(arr);      //[1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 4, 3, 2, 1, 1, 1]<br></code></pre></td></tr></table></figure>
<h3 id="方法十一"><a href="#方法十一" class="headerlink" title="方法十一"></a>方法十一</h3><p>此方法没有借助新数组直接改变原数组,并且去重后的数组被排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var arr = [1, 23, 1, 1, 1, 3, 23, 5, 6, 7, 9, 9, 8, 5];<br>function norepeat(arr) &#123;<br>  var temp;<br>  arr.sort();<br>  temp = arr[0];<br>  for (var i = 1; i &lt; arr.length; i++) &#123;<br>    if (arr[i] == temp) &#123;<br>      //当前元素如果和临时元素相等则将此元素从数组中删除<br>      arr.splice(i, 1);<br>      i--;<br>    &#125; else &#123;<br>      temp = arr[i];<br>    &#125;<br>  &#125;<br>  return arr;<br>&#125;<br>var arr2 = norepeat(arr);<br>console.log(arr2);     //[1, 23, 3, 5, 6, 7, 8, 9]<br>console.log(arr);      //[1, 23, 3, 5, 6, 7, 8, 9]<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>数组去重</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式布局</title>
    <url>/2020/11/14/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>响应式布局是一个网站能够兼容多个终端，而不是为每个终端做一个特定的版本，这个概念就是为解决移动互联网而诞生的</p>
<h2 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h2><p>通过css中的media query(媒介查询)@media功能来判断终端宽度在多少像素内，从而执行对应的css样式。<br><strong>优点</strong><br>面对不同分辨率设备灵活性强<br>能够解决设备显示适应问题<br><strong>缺点</strong><br>兼容各种设备工作量大，效率低下<br>代码累赘，会出现隐藏无用的元素，加载时间加长<br>其实这是一种折衷性质的设计解决方案，多方面因素影响而达不到最佳效果<br>一定程度上改变了网站原有的布局结构，会出现用户混淆的情况.域名查询 网站注册</p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta charset=&quot;utf-8&quot;&gt;<br>    &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot; /&gt;<br>    &lt;title&gt;响应式布局&lt;/title&gt;<br>    &lt;style type=&quot;text/css&quot;&gt;<br>        body,<br>        html &#123;<br>            margin: 0;<br>            padding: 0;<br>        &#125;<br><br>        .box &#123;<br>            height: 100px;<br>            color: #000;<br>            font-size: 16px;<br>            text-align: center;<br>            line-height: 100px;<br>            float: left;<br>        &#125;<br><br>        .box1 &#123;<br>            background: red;<br>        &#125;<br><br>        .box2 &#123;<br>            background: orange;<br>        &#125;<br><br>        .box3 &#123;<br>            background: yellow;<br>        &#125;<br><br>        .box4 &#123;<br>            background: green;<br>        &#125;<br><br>        @media(min-width: 768px) &#123;<br>            .box1 &#123;<br>                width: 20%;<br>            &#125;<br><br>            .box2 &#123;<br>                width: 60%;<br>            &#125;<br><br>            .box3 &#123;<br>                width: 20%;<br>            &#125;<br><br>            .box4 &#123;<br>                width: 100%;<br>            &#125;<br>        &#125;<br><br>        @media (min-width: 372px) and (max-width: 768px) &#123;<br>            .box1 &#123;<br>                width: 50%;<br>            &#125;<br><br>            .box2 &#123;<br>                width: 50%;<br>            &#125;<br><br>            .box3 &#123;<br>                width: 50%;<br>            &#125;<br><br>            .box4 &#123;<br>                width: 50%;<br>            &#125;<br>        &#125;<br><br>        @media (max-width: 372px) &#123;<br>            .box1 &#123;<br>                width: 100%;<br>            &#125;<br><br>            .box2 &#123;<br>                width: 100%;<br>            &#125;<br><br>            .box3 &#123;<br>                width: 100%;<br>            &#125;<br><br>            .box4 &#123;<br>                width: 100%;<br>            &#125;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div class=&quot;wrapper&quot;&gt;<br>        &lt;div class=&quot;box box1&quot;&gt;box1&lt;/div&gt;<br>        &lt;div class=&quot;box box2&quot;&gt;box2&lt;/div&gt;<br>        &lt;div class=&quot;box box3&quot;&gt;box3&lt;/div&gt;<br>        &lt;div class=&quot;box box4&quot;&gt;box4&lt;/div&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>响应式布局</tag>
      </tags>
  </entry>
  <entry>
    <title>星空特效</title>
    <url>/2023/03/13/%E6%98%9F%E7%A9%BA%E7%89%B9%E6%95%88/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>看到自己的电脑桌面是太空的界面，于是心血来潮，便有心次制作星空特效。<br>每次刷新页面都会生成新的页面</p>
<h3 id="案例展示"><a href="#案例展示" class="headerlink" title="案例展示"></a>案例展示</h3><div  align="center">    
<img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/2020-12-20 191248.jpg" width = 100% height = 100% />
</div> 

<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>	&lt;meta charset=&quot;utf-8&quot;&gt;<br>	&lt;title&gt;太空&lt;/title&gt;<br>	&lt;style&gt;<br>		body&#123;<br>			width: 100%;<br>			height: 1000px;<br>			background: linear-gradient(to bottom right, #000, #2073c2 60%, #dff6ff);<br>			overflow: hidden;<br>		&#125;<br>		span&#123;<br>			display: block;<br>			position: absolute;<br>			border-radius: 50%;<br>			box-shadow: 0.4px 0.4px 0.4px 0px #fff;<br>		&#125;<br>	&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br> <br>&lt;script&gt;<br>	window.onload = function()&#123;<br>		var screenW = document.documentElement.clientWidth;<br>		var screenH = document.documentElement.clientHeight;<br>		var colorArr = [&#x27;#fff&#x27;,&#x27;skyblue&#x27;,&#x27;orange&#x27;];<br>		for( var i=0; i&lt;800; i++ )&#123;<br>			var span = document.createElement(&#x27;span&#x27;);<br>			var width = Math.random() * 3;<br>			var colorIndex = parseInt(Math.random() * 3);<br>			var x = parseInt(Math.random() * screenW);<br>			var y = parseInt(Math.random() * screenH);<br>			span.style.width = parseInt(width) + &#x27;px&#x27;;<br>			span.style.height = parseInt(width) + &#x27;px&#x27;;<br>			span.style.background = colorArr[colorIndex];<br>			span.style.left = x + &#x27;px&#x27;;<br>			span.style.top = y + &#x27;px&#x27;;<br> <br>			document.body.appendChild(span);<br>		&#125;<br>	&#125;<br>&lt;/script&gt;<br> <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>炫酷特效</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>务必记住的200条Git命令</title>
    <url>/2023/03/13/%E5%8A%A1%E5%BF%85%E8%AE%B0%E4%BD%8F%E7%9A%84200%E6%9D%A1Git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我平时使用 Git 的时候，很多的 Git 命令我都不是很常用，工作中一般我们会配合一些可视化工具，或者编辑器自带的一些插件去维护 Git 仓库，但是我们也要记得一些常用 Git 命令来应变一些特殊的场景，下面是常用和不常用的一些 Git 命令</p>
<h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>创建一个新的 git 版本库。这个版本库的配置、存储等信息会被保存到.git 文件夹中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 初始化当前项目<br>$ git init<br><br># 新建一个目录，将其初始化为Git代码库<br>$ git init [project-name]<br><br># 在指定目录创建一个空的 Git 仓库。运行这个命令会创建一个名为 directory，只包含 .git 子目录的空目录。<br><br>$ git init --bare &lt;directory&gt;<br><br># 下载一个项目和它的整个代码历史<br># 这个命令就是将一个版本库拷贝到另一个目录中，同时也将分支都拷贝到新的版本库中。这样就可以在新的版本库中提交到远程分支<br>$ git clone [url]<br></code></pre></td></tr></table></figure>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>管理分支，可以通过下列命令对分支进行增删改查切换等</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 创建一个新的分支<br>$ git branch [branch-name]<br><br># 切换到指定分支，并更新工作区<br>$ git checkout [branch-name]<br><br># 以上两条命令合并,新建一个分支，并切换到该分支<br>$ git checkout -b [branch]<br><br># 查看所有的分支和远程分支<br>$ git branch -a<br><br># 重命名分支<br># git branch -m &lt;旧名称&gt; &lt;新名称&gt;<br>$ git branch -m [branch-name] [new-branch-name]<br><br># 编辑分支的介绍<br>$ git branch [branch-name] --edit-description<br><br># 列出所有本地分支<br>$ git branch<br><br># 列出所有远程分支<br>$ git branch -r<br><br># 新建一个分支，但依然停留在当前分支<br>$ git branch [branch-name]<br><br># 新建一个分支，指向指定commit<br>$ git branch [branch] [commit]<br><br># 新建一个分支，与指定的远程分支建立追踪关系<br>$ git branch --track [branch] [remote-branch]<br><br># 切换到上一个分支<br>$ git checkout -<br><br># 建立追踪关系，在现有分支与指定的远程分支之间<br>$ git branch --set-upstream [branch] [remote-branch]<br><br># 合并指定分支到当前分支<br>$ git merge [branch]<br><br># 选择一个commit，合并进当前分支<br>$ git cherry-pick [commit]<br><br># 删除分支<br>$ git branch -d [branch-name]<br><br># 删除远程分支<br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br><br># 切换到某个分支<br>$ git co &lt;branch&gt;<br><br># 创建新的分支，并且切换过去<br>$ git co -b &lt;new_branch&gt;<br><br># 基于branch创建新的new_branch<br>$ git co -b &lt;new_branch&gt; &lt;branch&gt;<br><br># 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除<br>$ git co $id<br><br># 把某次历史提交记录checkout出来，创建成一个分支<br>$ git co $id -b &lt;new_branch&gt;<br><br># 删除某个分支<br>$ git br -d &lt;branch&gt;<br><br># 强制删除某个分支 (未被合并的分支被删除的时候需要强制)<br>$ git br -D &lt;branch&gt;<br></code></pre></td></tr></table></figure>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 从远端origin的master分支更新版本库<br># git pull &lt;远端&gt; &lt;分支&gt;<br>$ git pull origin master<br><br># 抓取远程仓库所有分支更新并合并到本地，不要快进合并<br>$ git pull --no-ff<br></code></pre></td></tr></table></figure>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>显示索引文件（也就是当前工作空间）和当前的头指针指向的提交的不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 显示分支，未跟踪文件，更改和其他不同<br>$ git status<br><br># 查看其他的git status的用法<br>$ git help status<br></code></pre></td></tr></table></figure>
<h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><p>添加文件到当前工作空间中。如果你不使用 git add 将文件添加进去，那么这些文件也不会添加到之后的提交之中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 添加一个文件<br>$ git add test.js<br><br># 添加当前目录的所有文件到暂存区<br>$ git add .<br><br># 添加一个子目录中的文件<br>$ git add /path/to/file/test.js<br><br># 支持正则表达式<br>$ git add ./*.js<br><br># 添加指定文件到暂存区<br>$ git add [file1] [file2] ...<br><br># 添加指定目录到暂存区，包括子目录<br>$ git add [dir]<br><br># 添加每个变化前，都会要求确认<br># 对于同一个文件的多处变化，可以实现分次提交<br>$ git add -p<br></code></pre></td></tr></table></figure>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>rm 和上面的 add 命令相反，从工作空间中去掉某个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 移除 HelloWorld.js<br>$ git rm HelloWorld.js<br><br># 移除子目录中的文件<br>$ git rm /pather/to/the/file/HelloWorld.js<br><br># 删除工作区文件，并且将这次删除放入暂存区<br>$ git rm [file1] [file2] ...<br><br># 停止追踪指定文件，但该文件会保留在工作区<br>$ git rm --cached [file]<br></code></pre></td></tr></table></figure>
<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>将当前索引的更改保存为一个新的提交，这个提交包括用户做出的更改与信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 提交暂存区到仓库区附带提交信息<br>$ git commit -m [message]<br>$ git commit -m [message #指针]<br><br># 提交暂存区的指定文件到仓库区<br>$ git commit [file1] [file2] ... -m [message]<br><br># 提交工作区自上次commit之后的变化，直接到仓库区<br>$ git commit -a<br><br># 提交时显示所有diff信息<br>$ git commit -v<br><br># 使用一次新的commit，替代上一次提交<br># 如果代码没有任何新变化，则用来改写上一次commit的提交信息<br>$ git commit --amend -m [message]<br><br># 重做上一次commit，并包括指定文件的新变化<br>$ git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure>
<h3 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 上传本地指定分支到远程仓库<br># 把本地的分支更新到远端origin的master分支上<br># git push &lt;远端&gt; &lt;分支&gt;<br># git push 相当于 git push origin master<br>$ git push [remote] [branch]<br><br># 删除远程仓库<br>$ git remote rm &lt;repository&gt;<br><br># 下载远程仓库的所有变动<br>$ git fetch [remote]<br><br># 显示所有远程仓库<br>$ git remote -v<br><br># 显示某个远程仓库的信息<br>$ git remote show [remote]<br><br># 增加一个新的远程仓库，并命名<br>$ git remote add [shortname] [url]<br><br># 查看远程服务器地址和仓库名称<br>$ git remote -v<br><br># 添加远程仓库地址<br>$ git remote add origin git@ github:xxx/xxx.git<br><br># 设置远程仓库地址(用于修改远程仓库地址)<br>$ git remote set-url origin git@ github.com:xxx/xxx.git<br><br># 强行推送当前分支到远程仓库，即使有冲突<br>$ git push [remote] --force<br><br># 推送所有分支到远程仓库<br>$ git push [remote] --all<br></code></pre></td></tr></table></figure>
<h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 恢复暂存区的指定文件到工作区<br>$ git checkout [file]<br><br># 恢复暂存区的所有文件到工作区<br>$ git checkout .<br><br># 恢复某个commit的指定文件到暂存区和工作区<br>$ git checkout [commit] [file]<br><br># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变<br>$ git reset [file]<br><br># 重置暂存区与工作区，与上一次commit保持一致<br>$ git reset --hard<br><br># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变<br>$ git reset [commit]<br><br># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致<br>$ git reset --hard [commit]<br><br># 重置当前HEAD为指定commit，但保持暂存区和工作区不变<br>$ git reset --keep [commit]<br><br># 新建一个commit，用来撤销指定commit<br># 后者的所有变化都将被前者抵消，并且应用到当前分支<br>$ git revert [commit]<br><br># 恢复最后一次提交的状态<br>$ git revert HEAD<br><br># 暂时将未提交的变化移除，稍后再移入<br>$ git stash<br>$ git stash pop<br><br># 列所有stash<br>$ git stash list<br><br># 恢复暂存的内容<br>$ git stash apply<br><br># 删除暂存区<br>$ git stash drop<br></code></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>更改设置。可以是版本库的设置，也可以是系统的或全局的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 显示当前的Git配置<br>$ git config --list<br><br># 编辑Git配置文件<br>$ git config -e [--global]<br><br># 输出、设置基本的全局变量<br>$ git config --global user.email<br>$ git config --global user.name<br><br>$ git config --global user.email &quot;MyEmail@gmail.com&quot;<br>$ git config --global user.name &quot;My Name&quot;<br><br># 定义当前用户所有提交使用的作者邮箱。<br>$ git config --global alias.&lt;alias-name&gt; &lt;git-command&gt;<br><br># 为Git命令创建一个快捷方式（别名）。<br>$ git config --system core.editor &lt;editor&gt;<br></code></pre></td></tr></table></figure>
<h3 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h3><p>git 内置了对命令非常详细的解释，可以供我们快速查阅</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 查找可用命令<br>$ git help<br><br># 查找所有可用命令<br>$ git help -a<br><br># 在文档当中查找特定的命令<br># git help &lt;命令&gt;<br>$ git help add<br>$ git help commit<br>$ git help init<br></code></pre></td></tr></table></figure>
<h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>获取某些文件，某些分支，某次提交等 git 信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 显示commit历史，以及每次commit发生变更的文件<br>$ git log --stat<br><br># 搜索提交历史，根据关键词<br>$ git log -S [keyword]<br><br># 显示某个commit之后的所有变动，每个commit占据一行<br>$ git log [tag] HEAD --pretty=format:%s<br><br># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件<br>$ git log [tag] HEAD --grep feature<br><br># 显示某个文件的版本历史，包括文件改名<br>$ git log --follow [file]<br>$ git whatchanged [file]<br><br># 显示指定文件相关的每一次diff<br>$ git log -p [file]<br><br># 显示过去5次提交<br>$ git log -5 --pretty --oneline<br><br># 显示所有提交过的用户，按提交次数排序<br>$ git shortlog -sn<br><br># 显示指定文件是什么人在什么时间修改过<br>$ git blame [file]<br><br># 显示暂存区和工作区的差异<br>$ git diff<br><br># 显示暂存区和上一个commit的差异<br>$ git diff --cached [file]<br><br># 显示工作区与当前分支最新commit之间的差异<br>$ git diff HEAD<br><br># 显示两次提交之间的差异<br>$ git diff [first-branch]...[second-branch]<br><br># 显示今天你写了多少行代码<br>$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;<br><br># 比较暂存区和版本库差异<br>$ git diff --staged<br><br># 比较暂存区和版本库差异<br>$ git diff --cached<br><br># 仅仅比较统计信息<br>$ git diff --stat<br><br># 显示某次提交的元数据和内容变化<br>$ git show [commit]<br><br># 显示某次提交发生变化的文件<br>$ git show --name-only [commit]<br><br># 显示某次提交时，某个文件的内容<br>$ git show [commit]:[filename]<br><br># 显示当前分支的最近几次提交<br>$ git reflog<br><br># 查看远程分支<br>$ git br -r<br><br># 创建新的分支<br>$ git br &lt;new_branch&gt;<br><br># 查看各个分支最后提交信息<br>$ git br -v<br><br># 查看已经被合并到当前分支的分支<br>$ git br --merged<br><br># 查看尚未被合并到当前分支的分支<br>$ git br --no-merged<br><br></code></pre></td></tr></table></figure>
<h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><p>显示当前工作空间和提交的不同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 显示工作目录和索引的不同<br>$ git diff<br><br># 显示索引和最近一次提交的不同<br>$ git diff --cached<br><br># 显示工作目录和最近一次提交的不同<br>$ git diff HEAD<br></code></pre></td></tr></table></figure>
<h3 id="log"><a href="#log" class="headerlink" title="log"></a>log</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 显示所有提交<br>$ git log<br><br># 显示某几条提交信息<br>$ git log -n 10<br><br># 仅显示合并提交<br>$ git log --merges<br><br># 查看该文件每次提交记录<br>$ git log &lt;file&gt;<br><br># 查看每次详细修改内容的diff<br>$ git log -p &lt;file&gt;<br><br># 查看最近两次详细修改内容的diff<br>$ git log -p -2<br><br>#查看提交统计信息<br>$ git log --stat<br></code></pre></td></tr></table></figure>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>合并就是将外部的提交合并到自己的分支中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 将其他分支合并到当前分支<br>$ git merge branchName<br><br># 在合并时创建一个新的合并后的提交<br># 不要 Fast-Foward 合并，这样可以生成 merge 提交<br>$ git merge --no-ff branchName<br></code></pre></td></tr></table></figure>
<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>重命名或移动一个文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 重命名<br>$ git mv test.js test2.js<br><br># 移动<br>$ git mv test.js ./new/path/test.js<br><br># 改名文件，并且将这个改名放入暂存区<br>$ git mv [file-original] [file-renamed]<br><br># 强制重命名或移动<br># 这个文件已经存在，将要覆盖掉<br>$ git mv -f myFile existingFile<br></code></pre></td></tr></table></figure>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext"># 列出所有tag<br>$ git tag<br><br># 新建一个tag在当前commit<br>$ git tag [tag]<br><br># 新建一个tag在指定commit<br>$ git tag [tag] [commit]<br><br># 删除本地tag<br>$ git tag -d [tag]<br><br># 删除远程tag<br>$ git push origin :refs/tags/[tagName]<br><br># 查看tag信息<br>$ git show [tag]<br><br># 提交指定tag<br>$ git push [remote] [tag]<br><br># 提交所有tag<br>$ git push [remote] --tags<br><br># 新建一个分支，指向某个tag<br>$ git checkout -b [branch] [tag]<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序入坑</title>
    <url>/2023/03/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%85%A5%E5%9D%91/</url>
    <content><![CDATA[<h2 id="小程序简介"><a href="#小程序简介" class="headerlink" title="小程序简介"></a>小程序简介</h2><p>小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p>
<h3 id="小程序与普通网页开发的区别"><a href="#小程序与普通网页开发的区别" class="headerlink" title="小程序与普通网页开发的区别"></a>小程序与普通网页开发的区别</h3><p>小程序的主要开发语言是 JavaScript ，小程序的开发同普通的网页开发相比有很大的相似性。对于前端开发者而言，从网页开发迁移到小程序的开发成本并不高，但是二者还是有些许区别的。<br><code>普通网页开发</code>:<br>​ 渲染线程和脚本线程是互斥的。<br>网页开发者可以使用到各种浏览器暴露出来的 DOM API，进行 DOM 选中和操作<br>网页开发者需要面对的环境是各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ 浏览器等，在移动端需要面对 Safari、Chrome 以及 iOS、Android 系统中的各式 WebView<br><code>小程序</code>:<br>渲染线程和脚本线程是分开的，分别运行在不同的线程中。<br>小程序的逻辑层和渲染层是分开的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API，这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。<br>而小程序开发过程中需要面对的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具，小程序中三大运行环境也是有所区别的，如表所示。</p>
<table>
<thead>
<tr>
<th>运行环境</th>
<th>逻辑层</th>
<th>渲染层</th>
</tr>
</thead>
<tbody><tr>
<td>iOS</td>
<td>JavaScriptCore</td>
<td>WKWebView</td>
</tr>
<tr>
<td>安卓</td>
<td>V8</td>
<td>chromium 定制内核</td>
</tr>
<tr>
<td>小程序开发者工具</td>
<td>NWJS</td>
<td>Chrome WebView</td>
</tr>
</tbody></table>
<h3 id="小程序与普通网页开发文件对比"><a href="#小程序与普通网页开发文件对比" class="headerlink" title="小程序与普通网页开发文件对比"></a>小程序与普通网页开发文件对比</h3><table>
<thead>
<tr>
<th>结构</th>
<th>传统 Web</th>
<th>微信小程序</th>
</tr>
</thead>
<tbody><tr>
<td>结构</td>
<td>HTML</td>
<td>WXML</td>
</tr>
<tr>
<td>样式</td>
<td>CSS</td>
<td>WXCSS</td>
</tr>
<tr>
<td>逻辑</td>
<td>JavaScript</td>
<td>JavaScript</td>
</tr>
<tr>
<td>配置</td>
<td>无</td>
<td>JSON</td>
</tr>
</tbody></table>
<h3 id="基本项目目录结构"><a href="#基本项目目录结构" class="headerlink" title="基本项目目录结构"></a>基本项目目录结构</h3><div align="left">
<img src="https://gitee.com/zuo_jiahui/blogimage/raw/master/img/微信图片_20211007212116.png" width = 50% height = 80% />
</div>

<h3 id="小程序配置文件"><a href="#小程序配置文件" class="headerlink" title="小程序配置文件"></a>小程序配置文件</h3><p>小程序应用程序会包括最基本的两种配置文件，一种是全局的 <code>app.json</code> 和 页面自已的 <code>page.json</code></p>
<h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><p>小程序根目录下的 <code>app.json</code> 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 <code>tab</code> 等。<br>以下是一个包含了部分常用配置选项的 app.json ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;<br>  &quot;pages&quot;: [<br>    &quot;pages/index/index&quot;,<br>    &quot;pages/logs/index&quot;<br>  ],<br>  &quot;window&quot;: &#123;<br>    &quot;navigationBarTitleText&quot;: &quot;Demo&quot;<br>  &#125;,<br>  &quot;tabBar&quot;: &#123;<br>    &quot;list&quot;: [&#123;<br>      &quot;pagePath&quot;: &quot;pages/index/index&quot;,<br>      &quot;text&quot;: &quot;首页&quot;<br>    &#125;, &#123;<br>      &quot;pagePath&quot;: &quot;pages/logs/index&quot;,<br>      &quot;text&quot;: &quot;日志&quot;<br>    &#125;]<br>  &#125;,<br>  &quot;networkTimeout&quot;: &#123;<br>    &quot;request&quot;: 10000,<br>    &quot;downloadFile&quot;: 10000<br>  &#125;,<br>  &quot;debug&quot;: true<br>&#125;<br></code></pre></td></tr></table></figure>

<p>完整配置项说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html">小程序全局配置</a></p>
<h4 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h4><p>每一个小程序页面也可以使用同名 .json 文件来对本页面的窗口表现进行配置，页面中配置项会覆盖 app.json 的 window 中相同的配置项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;<br>  &quot;navigationBarBackgroundColor&quot;: &quot;#ffffff&quot;,<br>  &quot;navigationBarTextStyle&quot;: &quot;black&quot;,<br>  &quot;navigationBarTitleText&quot;: &quot;微信接口功能演示&quot;,<br>  &quot;backgroundColor&quot;: &quot;#eeeeee&quot;,<br>  &quot;backgroundTextStyle&quot;: &quot;light&quot;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>完整配置项说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/page.html">小程序页面配置</a></p>
<h4 id="sitemap-配置"><a href="#sitemap-配置" class="headerlink" title="sitemap 配置"></a>sitemap 配置</h4><p>小程序根目录下的 <code>sitemap.json</code> 文件用于配置小程序及其页面是否被微信索引<br>完整配置项说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/sitemap.html">sitemap 配置</a></p>
<h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><p>组件使用说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/component/">组件文档</a></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><p>.js 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Page(&#123;<br>  data: &#123;<br>    msg: &quot;Hello !!!&quot;,<br>    num: 100,<br>    show: true,<br>    parson: &#123;<br>      name: &quot;鸣人&quot;,<br>      age: 18<br>    &#125;<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>.wxml 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;view&gt;<br>  &lt;!-- 字符串类型 --&gt;<br>  &lt;view&gt;&#123;&#123;msg&#125;&#125;&lt;/view&gt;<br>  &lt;!-- 数字类型 --&gt;<br>  &lt;view&gt;&#123;&#123;num&#125;&#125;&lt;/view&gt;<br>  &lt;!-- 布尔类型 --&gt;<br>  &lt;checkbox checked=&quot;&#123;&#123;show&#125;&#125;&quot;&gt;是否展示&lt;/checkbox&gt;<br>  &lt;!-- 对象类型 --&gt;<br>  &lt;view&gt;名字 : &#123;&#123;parson.name&#125;&#125; 年龄 : &#123;&#123;parson.age&#125;&#125;&lt;/view&gt;<br>&lt;/view&gt;<br></code></pre></td></tr></table></figure>

<h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;view&gt;<br>  &lt;!-- 数字加减 --&gt;<br>  &lt;view&gt;&#123;&#123;1 + 1&#125;&#125;&lt;/view&gt;<br>  &lt;!-- 字符串拼接 --&gt;<br>  &lt;view&gt;&#123;&#123;&quot;1&quot; + &quot;1&quot;&#125;&#125;&lt;/view&gt;<br>  &lt;!-- 三元表达式 --&gt;<br>  &lt;view&gt;&#123;&#123;10 % 2 === 0 ? &quot;偶数&quot; : &quot;奇数&quot;&#125;&#125;&lt;/view&gt;<br>&lt;/view&gt;<br></code></pre></td></tr></table></figure>

<h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>.js 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Page(&#123;<br>  data: &#123;<br>    dataList: [&#123;<br>        id: 1,<br>        name: &quot;鸣人&quot;<br>      &#125;,<br>      &#123;<br>        id: 2,<br>        name: &quot;佐助&quot;<br>      &#125;,<br>      &#123;<br>        id: 2,<br>        name: &quot;雏田&quot;<br>      &#125;,<br>      &#123;<br>        id: 2,<br>        name: &quot;小樱&quot;<br>      &#125;,<br>    ],<br>    parson: &#123;<br>      name: &quot;鸣人&quot;,<br>      age: 18<br>    &#125;<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>.wxml 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;view&gt;<br>  &lt;!-- wx:for=&quot;&#123;&#123;数组或者对象&#125;&#125;&quot; wx:for-item=&quot;循环项的名称&quot; wx:for-index=&quot;循环项的索引&quot; wx:key=&quot;唯一值，用于提高列表渲染性能&quot; --&gt;<br>  &lt;!-- 如果数组为普通数组 列如：[1,2,3,4]   wx:key=&quot;*this&quot;  *this 表示循环项--&gt;<br>  &lt;!--<br>  默认情况下:<br>  可以不写 wx:for-item=&quot;item&quot;  wx:for-index=&quot;index&quot;，小程序会默认添加(只有一层循环下可以省略)<br>  当出现 数组的嵌套循环的时候 以下绑定 不能重名<br>  wx:for-item=&quot;item&quot;  wx:for-index=&quot;index&quot;<br>  --&gt;<br>  &lt;view wx:for=&quot;&#123;&#123;dataList&#125;&#125;&quot; wx:for-item=&quot;item&quot; wx:for-index=&quot;index&quot; wx:key=&quot;id&quot;&gt;<br>    索引 ：&#123;&#123;index&#125;&#125;<br>    值 ： &#123;&#123;item.name&#125;&#125;<br>  &lt;/view&gt;<br><br>  &lt;view wx:for=&quot;&#123;&#123;parson&#125;&#125;&quot; wx:for-item=&quot;value&quot; wx:for-index=&quot;key&quot; wx:key=&quot;id&quot;&gt;<br>    属性：&#123;&#123;key&#125;&#125;<br>    值：&#123;&#123;value&#125;&#125;<br>  &lt;/view&gt;<br>&lt;/view&gt;<br></code></pre></td></tr></table></figure>

<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!--<br>  场景使用：<br>   wx:if ：当标签不是频繁切换的时候优先使用 （直接把标签从页面移除）<br>   hidden ：当标签频繁切换的时候优先使用 （通过使用样式的方式来切换显示）<br>   注意 ：(hidden 属性不可和样式 display 一起使用，否则 hidden 属性会失效)<br>--&gt;<br>&lt;view&gt;<br>  &lt;!-- wx:if=&quot;&#123;&#123;true/false&#125;&#125;&quot; --&gt;<br>  &lt;view wx:if=&quot;&#123;&#123;true&#125;&#125;&quot;&gt; 显示 &lt;/view&gt;<br>  &lt;view wx:if=&quot;&#123;&#123;false&#125;&#125;&quot;&gt; 隐藏 &lt;/view&gt;<br><br>  &lt;!-- wx:if  wx:elif wx:else--&gt;<br>  &lt;view wx:if=&quot;&#123;&#123;false&#125;&#125;&quot;&gt; 1 &lt;/view&gt;<br>  &lt;view wx:elif=&quot;&#123;&#123;false&#125;&#125;&quot;&gt; 2 &lt;/view&gt;<br>  &lt;view wx:else&gt; 3 &lt;/view&gt;<br><br>  &lt;!-- hidden 默认为 true--&gt;<br>  &lt;view hidden=&quot;&#123;&#123;false&#125;&#125;&quot;&gt;hidden1&lt;/view&gt;<br>  &lt;view hidden&gt;hidden2&lt;/view&gt;<br>&lt;/view&gt;<br></code></pre></td></tr></table></figure>

<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>.js 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Page(&#123;<br>  data: &#123;<br>    num: 0<br>  &#125;,<br><br>  // 输入框事件<br>  handInput(e) &#123;<br>    this.setData(&#123;<br>      num: Number(e.detail.value)<br>    &#125;)<br>  &#125;,<br><br>  //加 减 事件<br>  handbindtap(value) &#123;<br>    const num = value.currentTarget.dataset.num<br>    this.setData(&#123;<br>      num: this.data.num + num<br>    &#125;)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>.wxml 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;view&gt;<br>  &lt;input type=&quot;text&quot; bindinput=&quot;handInput&quot; /&gt;<br>  &lt;button bindtap=&quot;handbindtap&quot; data-num=&quot;&#123;&#123;1&#125;&#125;&quot;&gt;+&lt;/button&gt;<br>  &lt;button bindtap=&quot;handbindtap&quot; data-num=&quot;&#123;&#123;-1&#125;&#125;&quot;&gt;-&lt;/button&gt;<br>  &lt;view&gt;&#123;&#123;num&#125;&#125;&lt;/view&gt;<br>&lt;/view&gt;<br></code></pre></td></tr></table></figure>

<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><p>详情使用说明请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/">自定义组件文档</a></p>
<h3 id="创建自定义组件"><a href="#创建自定义组件" class="headerlink" title="创建自定义组件"></a>创建自定义组件</h3><p>类似于页面，一个自定义组件由 json wxml wxss js 4 个文件组成。要编写一个自定义组件，首先需要在 json 文件中进行自定义组件声明（将 component 字段设为 true 可将这一组文件设为自定义组件）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;<br>  &quot;component&quot;: true<br>&#125;<br></code></pre></td></tr></table></figure>
<p>同时，还要在 wxml 文件中编写组件模板，在 wxss 文件中加入组件样式，它们的写法与页面的写法类似。具体细节和注意事项参见 <a href="https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/wxml-wxss.html">组件模板和样式</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!-- 这是自定义组件的内部WXML结构 --&gt;<br>&lt;view class=&quot;inner&quot;&gt;<br>  &#123;&#123;innerText&#125;&#125;<br>&lt;/view&gt;<br>&lt;slot&gt;&lt;/slot&gt;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">/* 这里的样式只应用于这个自定义组件 */<br>.inner &#123;<br>  color: red;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在自定义组件的 js 文件中，需要使用 Component() 来注册组件，并提供组件的属性定义、内部数据和自定义方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Component(&#123;<br>  properties: &#123;<br>    // 这里定义了innerText属性，属性值可以在组件使用时指定，由父级传递过来<br>    innerText: &#123;<br>      type: String,<br>      value: &#x27;default value&#x27;,    //默认值<br>    &#125;<br>  &#125;,<br>  data: &#123;<br>    // 这里是一些组件内部数据<br>    someData: &#123;&#125;<br>  &#125;,<br>  methods: &#123;<br>    // 这里是一个自定义组件自已的方法<br>    customMethod: function()&#123;&#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>使用自定义组件: 使用已注册的自定义组件前，首先要在页面的 json 文件中进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&#123;<br>  &quot;usingComponents&quot;: &#123;<br>    &quot;component-tag-name&quot;: &quot;path/to/the/custom/component&quot;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="Component-构造器"><a href="#Component-构造器" class="headerlink" title="Component 构造器"></a>Component 构造器</h3><p>Component 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。<br>详细的参数含义和使用请参考 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html">Component 参考文档</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Component(&#123;<br><br>  behaviors: [],<br><br>  properties: &#123;<br>    myProperty: &#123; // 属性名<br>      type: String,<br>      value: &#x27;&#x27;<br>    &#125;,<br>    myProperty2: String // 简化的定义方式<br>  &#125;,<br>  <br>  data: &#123;&#125;, // 私有数据，可用于模板渲染<br><br>  lifetimes: &#123;<br>    // 生命周期函数，可以为函数，或一个在methods段中定义的方法名<br>    attached: function () &#123; &#125;,<br>    moved: function () &#123; &#125;,<br>    detached: function () &#123; &#125;,<br>  &#125;,<br><br>  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名<br>  attached: function () &#123; &#125;, // 此处attached的声明会被lifetimes字段中的声明覆盖<br>  ready: function() &#123; &#125;,<br><br>  pageLifetimes: &#123;<br>    // 组件所在页面的生命周期函数<br>    show: function () &#123; &#125;,<br>    hide: function () &#123; &#125;,<br>    resize: function () &#123; &#125;,<br>  &#125;,<br><br>  methods: &#123;<br>    onMyButtonTap: function()&#123;<br>      this.setData(&#123;<br>        // 更新属性和数据的方法与更新页面数据的方法类似<br>      &#125;)<br>    &#125;,<br>    // 内部方法建议以下划线开头<br>    _myPrivateMethod: function()&#123;<br>      // 这里将 data.A[0].B 设为 &#x27;myPrivateData&#x27;<br>      this.setData(&#123;<br>        &#x27;A[0].B&#x27;: &#x27;myPrivateData&#x27;<br>      &#125;)<br>    &#125;,<br>    _propertyChange: function(newVal, oldVal) &#123;<br><br>    &#125;<br>  &#125;<br><br>&#125;)<br></code></pre></td></tr></table></figure>
<h3 id="组件间通信与事件"><a href="#组件间通信与事件" class="headerlink" title="组件间通信与事件"></a>组件间通信与事件</h3><p>组件间的基本通信方式有以下几种  </p>
<ul>
<li>WXML 数据绑定：用于父组件向子组件的指定属性设置数据，仅能设置 JSON 兼容数据（自基础库版本 2.0.9 开始，还可以在数据中包含函数）。具体在 组件模板和样式 章节中介绍。</li>
<li>事件：用于子组件向父组件传递数据，可以传递任意数据。</li>
<li>如果以上两种方式不足以满足需要，父组件还可以通过 this.selectComponent 方法获取子组件实例对象，这样就可以直接访问组件的任意数据和方法</li>
</ul>
<h4 id="父子组件传值"><a href="#父子组件传值" class="headerlink" title="父子组件传值"></a>父子组件传值</h4>]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>call apply bind三者之间的区别及作用</title>
    <url>/2023/03/13/bind,call,apply%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>说到 call apply bind 这三者那就老生常谈，因为这三者之间属于高频面试题，每一次面试中基本都会有面试官问call、apply、bind的区别以及实现原理</p>
<h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>call、apply、bind三者都是用来调用函数并且改变函数内部的this指向</p>
<h3 id="三者之间的区别"><a href="#三者之间的区别" class="headerlink" title="三者之间的区别"></a>三者之间的区别</h3><h4 id="call-与-apply"><a href="#call-与-apply" class="headerlink" title="call 与 apply"></a>call 与 apply</h4><p>其实 call 与 apply 几乎没有差别，如果有，也就传参方式不同<br><code>call</code> : 需要把实参列表按照形参列表的个数传进去<br><code>apply</code> : 需要传递一个 arguments</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var name = &quot;鸣人&quot;,<br>     age = 18;<br>var obj1 = &#123;<br>  name: &quot;雏田&quot;,<br>  age: 17,<br>&#125;;<br>var obj = &#123;<br>  name: &quot;佐助&quot;,<br>   age: 20,<br>   say: function () &#123;<br>   console.log(&quot;姓名&quot; + this.name + &quot;年龄&quot; + this.age);<br>   &#125;,<br>&#125;;<br>obj.say(); // 姓名佐助年龄20  这里 obj 调用 say 方法，所以 this 指向 obj<br>//1.非严格模式下，如果参数不传,或者第一个传递的是null/undefined,this是window<br>//2.严格模式下：不传，this是undefined<br>obj.say.call();       // 姓名鸣人年龄18  此时 this 指向 window<br>obj.say.call(obj1);   // 姓名雏田年龄17  此时 this 指向 obj1<br>obj.say.apply();      // 姓名鸣人年龄18  此时 this 指向 window<br>obj.say.apply(obj1);  // 姓名雏田年龄17  此时 this 指向 obj1<br><br><br>//  在来看看传参方式<br>var newobj = &#123;<br>  name: &quot;佐助&quot;,<br>   age: 20,<br> myfun: function (fm, t) &#123;<br>   console.log(this.name + &quot;年龄&quot; + this.age, &quot;来自&quot; + fm + &quot;去往&quot; + t);<br> &#125;,<br>&#125;;<br>var newobj1 = &#123;<br>  name: &quot;小樱&quot;,<br>   age: 18,<br>&#125;;<br>newobj.myfun(&quot;上海&quot;,&quot;北京&quot;)                    // 佐助年龄20 来自上海去往北京<br>newobj.myfun.call(newobj1,&quot;成都&quot;,&quot;北京&quot;)       // 小樱年龄18 来自成都去往北京<br>newobj.myfun.apply(newobj1,[&quot;东京&quot;,&quot;上海&quot;])    // 小樱年龄18 来自东京去往上海<br></code></pre></td></tr></table></figure>
<h4 id="call-与-bind"><a href="#call-与-bind" class="headerlink" title="call 与 bind"></a>call 与 bind</h4><p><code>call</code>: 不需要调用，自执行<br><code>bind</code>: 返回的是一个新的函数，你必须调用它才会被执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var newobj = &#123;<br>  name: &quot;佐助&quot;,<br>   age: 20,<br> myfun: function (fm, t) &#123;<br>   console.log(this.name + &quot;年龄&quot; + this.age, &quot;来自&quot; + fm + &quot;去往&quot; + t);<br> &#125;,<br>&#125;;<br>var newobj1 = &#123;<br>  name: &quot;小樱&quot;,<br>   age: 18,<br>&#125;;<br>newobj.myfun.call(newobj1,&#x27;巴黎&#x27;, &#x27;东京&#x27;)      // 小樱年龄18 来自巴黎去往东京<br>newobj.myfun.bind(newobj1,&#x27;上海&#x27;, &#x27;成都&#x27;)()    // 小樱年龄18 来自上海去往成都<br>newobj.myfun.bind(newobj1,[&#x27;上海&#x27;, &#x27;成都&#x27;])()  // 小樱年龄18 来自上海,成都去往undefined<br></code></pre></td></tr></table></figure>
<h3 id="栗子"><a href="#栗子" class="headerlink" title="栗子"></a>栗子</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">function fn(a, b) &#123;<br>	this.c = 3<br>	console.log(a, b, this)<br>&#125;<br><br>fn(1, 2) //  打印1, 2, Window<br><br>console.log(c) //  打印3<br><br>const obj = &#123;d: 4&#125;<br><br>fn.call(obj, 1, 2) //  打印1, 2, &#123;d: 4&#125;<br><br>fn.apply(obj, [1, 2]) //  打印1, 2, &#123;d: 4&#125;<br><br>fn.call(null, 1, 2) //  打印1, 2, window<br><br>fn.call(undefined, 1, 2) //  打印1, 2, window<br><br>fn.bind(obj)(1, 2) //  打印1,2，&#123;d: 4&#125;<br><br>fn.bind(obj, 5)(1, 2) //  打印5, 1, &#123;d: 4&#125;<br><br>fn.bind(obj, 5, 3)(1, 2) //  打印5, 3, &#123;d: 4&#125; <br><br></code></pre></td></tr></table></figure>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Function.prototype.call = function (obj, ...args) &#123;<br>    // 错误写法，有同学问fn调用call，那么这里的this是指向fn，直接调用函数并传入参数不就可以了吗？<br>    // this(...args)<br>    <br>    // 上面这种写法，并不能改变fn函数内部的this指向，所以不符合的我们的需求。我们应该是让obj去调用fn函数，才能让fn指向obj<br>    <br>    // 1. 处理obj是undefined或者null的情况<br>    if (obj === undefinded || obj === null) &#123;<br>        obj = window<br>    &#125;<br>        <br>    // 2. 给obj添加一个方法tmpFn，等于fn函数<br>    obj.tmpFn = this<br>    <br>    // 3. 调用obj的tmpFn的方法，并保存执行结果，此时fn函数中this指向obj<br>    const result = obj.tmpFn(...args)<br>    <br>    // 4. 删除obj上的tmpFn<br>    delete obj.tmpFn<br>    <br>    // 5. 返回方法的返回值<br>    return result<br>&#125;<br><br>Function.prototype.apply = function (obj, args) &#123;<br>    // 1. 处理obj是undefined或者null的情况<br>    if (obj === undefinded || obj === null) &#123;<br>        obj = window<br>    &#125;<br>    // 2. 给obj添加一个方法tmpFn，等于fn函数<br>    obj.tmpFn = this<br>    <br>    // 3. 调用obj的tmpFn的方法<br>    const result = obj.tmpFn(args)<br>    <br>    // 4. 删除obj上的tmpFn<br>    delete obj.tmpFn<br>    <br>    // 5. 返回方法的返回值<br>    return result<br>&#125;<br><br>Function.prototype.bind = function (obj, ...args) &#123;<br>    // 1. 返回一个新函数，这里采用es6 箭头函数写法，不懂的同学自行学习<br>    return (...args2) =&gt; &#123;<br>		// 2. 调用原来函数，改变this指向obj，参数列表由args和args2依次组成。<br>        return this.call(obj, ...args, ...args2) // 这里this.call的this指向的是fn函数，也就是调用bind的函数。<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>call</tag>
        <tag>apply</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript中this指向问题</title>
    <url>/2023/03/13/JavaScript%E4%B8%ADthis%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>面向对象语言中 this 表示当前对象的一个引用,但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<h3 id="1-全局作用域或者普通函数中-this-指向全局对象-window"><a href="#1-全局作用域或者普通函数中-this-指向全局对象-window" class="headerlink" title="1. 全局作用域或者普通函数中 this 指向全局对象 window"></a>1. 全局作用域或者普通函数中 this 指向全局对象 window</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//直接打印<br>var a = 10;<br>console.log(this.a)<br></code></pre></td></tr></table></figure>
<blockquote>
<p>10</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//function声明函数<br>var a = 10;<br>function bar() &#123;<br>  var a = 20<br>  console.log(this.a);<br>&#125;<br>bar();<br></code></pre></td></tr></table></figure>
<blockquote>
<p>10</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//function声明函数赋给变量<br>var a = 10;<br>var bar = function () &#123;<br>  var a = 20;<br>  console.log(this.a);<br>&#125;;<br>bar();<br></code></pre></td></tr></table></figure>
<blockquote>
<p>10</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//立即执行函数<br>var a = 10;<br>(function () &#123;<br>  var a = 20;<br>  console.log(this.a);<br>&#125;)();<br></code></pre></td></tr></table></figure>
<blockquote>
<p>10</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//定时器方法<br>var a = 10;<br>setInterval(function () &#123;<br>    var a = 20<br>  console.log(this.a);<br>&#125;, 2000);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>10</p>
</blockquote>
<h3 id="2-方法调用中谁调用-this-指向谁"><a href="#2-方法调用中谁调用-this-指向谁" class="headerlink" title="2. 方法调用中谁调用 this 指向谁"></a>2. 方法调用中谁调用 this 指向谁</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//对象方法调用<br>var a = 10;<br>var person = &#123;<br>  a: 20,<br>  run: function () &#123;<br>    console.log(this.a);<br>  &#125;,<br>&#125;;<br>person.run();<br></code></pre></td></tr></table></figure>
<blockquote>
<p>20</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!-- 事件绑定 --&gt;<br>&lt;button type=&quot;button&quot;&gt;点我&lt;/button&gt;<br>&lt;script&gt;<br>  var btn = document.querySelector(&quot;button&quot;);<br>  btn.onclick = function () &#123;<br>    console.log(this);<br>  &#125;;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>&lt; button button button type=”button”&gt;点我 &lt; /button&gt;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">&lt;!-- 事件监听 --&gt;<br>&lt;button type=&quot;button&quot;&gt;点我&lt;/button&gt;<br>&lt;script&gt;<br>  var btn = document.querySelector(&quot;button&quot;);<br>  btn.addEventListener(&quot;click&quot;, function () &#123;<br>    console.log(this);<br>  &#125;);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>&lt; button button button type=”button”&gt;点我 &lt; /button&gt;</p>
</blockquote>
<h3 id="3-在构造函数或者构造函数原型对象中-this-指向构造函数的实例"><a href="#3-在构造函数或者构造函数原型对象中-this-指向构造函数的实例" class="headerlink" title="3. 在构造函数或者构造函数原型对象中 this 指向构造函数的实例"></a>3. 在构造函数或者构造函数原型对象中 this 指向构造函数的实例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//不使用new指向window<br>function Person(name) &#123;<br>  console.log(this)     // window<br>  this.name = name;<br>&#125;<br>Person(&#x27;inwe&#x27;)<br>//使用new<br>function Person(name) &#123;<br>  this.name = name<br>  console.log(this)     //people<br>  self = this<br>&#125;<br>var people = new Person(&#x27;iwen&#x27;)<br>console.log(self === people)       //true<br>//这里new改变了this指向，将this由window指向Person的实例对象people<br></code></pre></td></tr></table></figure>
<blockquote>
<p>window<br>people<br>true</p>
</blockquote>
<h3 id="4-箭头函数中指向外层作用域的-this"><a href="#4-箭头函数中指向外层作用域的-this" class="headerlink" title="4. 箭头函数中指向外层作用域的 this"></a>4. 箭头函数中指向外层作用域的 this</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">var obj = &#123;<br>  foo() &#123;<br>    console.log(this);<br>  &#125;,<br>  bar: () =&gt; &#123;<br>    console.log(this);<br>  &#125;<br>&#125;<br>obj.foo()    // &#123;foo: ƒ, bar: ƒ&#125;<br>obj.bar()    // window<br></code></pre></td></tr></table></figure>
<blockquote>
<p>{foo: ƒ, bar: ƒ}<br>window</p>
</blockquote>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title>hooks使用</title>
    <url>/2023/03/13/hooks%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>hooks是 16.8 版本之后的新特性，React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 组件的最佳写法应该是函数，而不是类。<br>React 早就支持函数组件，<br>但是，这种写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。<br>React Hooks 的设计目的，就是加强版函数组件，完全不使用”类”，就能写出一个全功能的组件。<br>Hooks可以让无状态组件实现有状态组件的部分功能，比如设置state，使用钩子函数</p>
<h2 id="useState-状态"><a href="#useState-状态" class="headerlink" title="useState - 状态"></a>useState - 状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment, useState &#125; from &#x27;react&#x27;;<br>const HooksCompont = () =&gt; &#123;<br>  const [count, setCount] = useState(0);<br>  return (<br>    &lt;Fragment&gt;<br>      &lt;h3&gt;hello hooks!! &#123;count&#125;&lt;/h3&gt;<br>      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;加&lt;/button&gt;<br>    &lt;/Fragment&gt;<br>  );<br>&#125;;<br>export default HooksCompont;<br></code></pre></td></tr></table></figure>
<h2 id="useEffect-副作用"><a href="#useEffect-副作用" class="headerlink" title="useEffect - 副作用"></a>useEffect - 副作用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment, useState, useEffect &#125; from &#x27;react&#x27;;<br>const HooksCompont = () =&gt; &#123;<br>  const [count, setCount] = useState(0);<br>  const [disable, setDisable] = useState(true);<br>  // useEffect 相当于 conmponentDidMout,conmponentDidUpdate和 conmponentWillUnmount<br>  useEffect(() =&gt; &#123;<br>    console.log(count, &#x27;页面挂载&#x27;);<br>    if (count === 2) &#123;<br>      console.log(count, &#x27;变化&#x27;);<br>    &#125;<br>    return () =&gt; &#123;<br>      // 这里相当于conmponentWillUnmount (页面离开时)<br>      // 但是如果 第二参数值 发生改变时，触发副作用函数，并且执行里面逻辑<br>      console.log(&#x27;执行离开&#x27;);<br>    &#125;;<br>    // 当 useEffect 未添加第二个参数时 ：页面每次重新渲染(任意点击按钮),都要执行一遍这些副作用函数，显然是不经济的。<br>    // 怎么跳过一些不必要的计算呢？我们需要给 useEffect 传第二个参数即可。<br>    // 用第二个参数来告诉 react只有当  这个参数的值 发生改变时，才执行我们传的副作用函数（第一个参数）。<br>  &#125;, [count]);<br><br>  useEffect(() =&gt; &#123;<br>    return () =&gt; &#123;<br>      // 这里相当于conmponentWillUnmount (页面离开时)<br>      console.log(&#x27;离开&#x27;);<br>    &#125;;<br>  &#125;, []);<br>  return (<br>    &lt;Fragment&gt;<br>      &lt;h3&gt;hello hooks!! &#123;count&#125;&lt;/h3&gt;<br>      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;加&lt;/button&gt;<br>      &lt;button onClick=&#123;() =&gt; setDisable(!disable)&#125;&gt;&#123;disable ? &#x27;启用&#x27; : &#x27;禁用&#x27;&#125;&lt;/button&gt;<br>    &lt;/Fragment&gt;<br>  );<br>&#125;;<br>export default HooksCompont;<br></code></pre></td></tr></table></figure>
<h2 id="userReducer-复杂状态处理"><a href="#userReducer-复杂状态处理" class="headerlink" title="userReducer - 复杂状态处理"></a>userReducer - 复杂状态处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment, useReducer &#125; from &#x27;react&#x27;;<br>const ReducerDemo = () =&gt; &#123;<br>  const initialState = &#123; count: 0, name: &#x27;鸣人&#x27; &#125;;<br>  const reducer = (state, action) =&gt; &#123;<br>    const &#123; type, payload = 1 &#125; = action;<br>    switch (type) &#123;<br>      case &#x27;increment&#x27;:<br>        return &#123; ...state, count: state.count + payload &#125;;<br>      case &#x27;decrement&#x27;:<br>        return &#123; ...state, count: state.count - payload &#125;;<br>      case &#x27;rename&#x27;:<br>        return &#123; ...state, name: payload &#125;;<br>      default:<br>        throw new Error();<br>    &#125;<br>  &#125;;<br>  // 第一位参数是函数, 第二参数为初始值<br>  // useReducer((state, action)=&gt;&#123;&#125;, 0)<br>  // const [state, dispatch] = useReducer(reducer, initialArg);<br>  const [state, dispatch] = useReducer(reducer, initialState);<br>  return (<br>    &lt;Fragment&gt;<br>      &lt;div&gt;<br>        useReducer &#123;state.count&#125; ---- &#123;state.name&#125;<br>      &lt;/div&gt;<br>      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;increment&#x27; &#125;)&#125;&gt;加&lt;/button&gt;<br>      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;decrement&#x27;, payload: 2 &#125;)&#125;&gt;减&lt;/button&gt;<br>      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;rename&#x27;, payload: &#x27;佐助&#x27; &#125;)&#125;&gt;changeName&lt;/button&gt;<br>    &lt;/Fragment&gt;<br>  );<br>&#125;;<br>export default ReducerDemo;<br></code></pre></td></tr></table></figure>
<h2 id="useContext-深层值传递"><a href="#useContext-深层值传递" class="headerlink" title="useContext - 深层值传递"></a>useContext - 深层值传递</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment, useState, createContext, useContext &#125; from &#x27;react&#x27;;<br><br>// 创建 Context<br>const theme = createContext(&#x27;#fff&#x27;);<br><br>const Demo = () =&gt; &#123;<br>  return &lt;Child /&gt;;<br>&#125;;<br><br>const Child = () =&gt; &#123;<br>  const father = useContext(theme);<br>  const style = &#123;<br>    backgroundColor: father.bgColor,<br>  &#125;;<br>  return (<br>    // 消费者<br>    &lt;Fragment&gt;<br>      &#123;/* 第一种写法 */&#125;<br>      &lt;div style=&#123;style&#125;&gt;&#123;father.content&#125;&lt;/div&gt;<br>      &#123;/* 第二种 使用 Consumer 属性 */&#125;<br>      &lt;theme.Consumer&gt;&#123;(value) =&gt; &lt;div&gt;&#123;value.bgColor&#125;&lt;/div&gt;&#125;&lt;/theme.Consumer&gt;<br>    &lt;/Fragment&gt;<br>  );<br>&#125;;<br><br>const HooksContext = () =&gt; &#123;<br>  // 深层值传递相当于 生产者 和 消费者模式<br>  const [bgColor, setBgColor] = useState(&#x27;#fff&#x27;);<br>  return (<br>    &lt;Fragment&gt;<br>      &lt;input<br>        type=&quot;color&quot;<br>        onChange=&#123;(e) =&gt; &#123;<br>          setBgColor(e.target.value);<br>        &#125;&#125;<br>      /&gt;<br>      &#123;/* 生产者 */&#125;<br>      &lt;theme.Provider value=&#123;&#123; bgColor, content: &#x27;Child&#x27; &#125;&#125;&gt;<br>        &lt;Demo /&gt;<br>      &lt;/theme.Provider&gt;<br>    &lt;/Fragment&gt;<br>  );<br>&#125;;<br>export default HooksContext;<br><br></code></pre></td></tr></table></figure>
<h2 id="useRef-引用"><a href="#useRef-引用" class="headerlink" title="useRef - 引用"></a>useRef - 引用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment, useEffect, useRef, forwardRef &#125; from &#x27;react&#x27;;<br><br>const Input = forwardRef((prpos, ref) =&gt; &#123;<br>  // 将ref父类的ref作为参数传入函数式组件中，本身props只带有children这个参数，这样可以让子类转发父类的ref,<br>  // 当父类把ref挂在到子组件上时，子组件外部通过forwrardRef包裹，可以直接将父组件创建的ref挂在到子组件的某个dom元素<br>  return &lt;input &#123;...prpos&#125; ref=&#123;ref&#125; /&gt;;<br>&#125;);<br><br>const RefDemo = () =&gt; &#123;<br>  // 用于获取元素的原生DOM或者获取自定义组件所暴露出来的ref方法(父组件可以通过ref获取子组件，并调用相对应子组件中的方法)<br>  const inputRef = useRef();<br>  useEffect(() =&gt; &#123;<br>    inputRef.current.focus();<br>    inputRef.current.value = &#x27;hello react&#x27;;<br>  &#125;, []);<br>  return (<br>    &lt;Fragment&gt;<br>      &lt;Input placeholder=&quot;请输入&quot; ref=&#123;inputRef&#125; /&gt;<br>    &lt;/Fragment&gt;<br>  );<br>&#125;;<br>export default RefDemo;<br><br></code></pre></td></tr></table></figure>
<h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">import React, &#123; Fragment, useState, useMemo &#125; from &#x27;react&#x27;;<br><br>const Child = (&#123; name, children &#125;) =&gt; &#123;<br>  const change = () =&gt; &#123;<br>    // 要求点击 鸣人 才执行此语句    现点击任何按钮都会执行 导致子组件重新渲染<br>    // 原因 : 父组件任何一个状态发生变化，子组件的代码块都会重新执行一遍<br>    window.console.log(&#x27;鸣人分身&#x27;);<br>    return name;<br>  &#125;;<br>  //  useMemo 是在DOM更新前触发的<br>  const actionChange = useMemo(()=&gt;change(),[name]);<br>  return (<br>    &lt;Fragment&gt;<br>      &lt;div&gt;&#123;actionChange&#125;&lt;/div&gt;<br>      &lt;div&gt;&#123;children&#125;&lt;/div&gt;<br>    &lt;/Fragment&gt;<br>  );<br>&#125;;<br>const Demo = () =&gt; &#123;<br>  const [mingren, setMingren] = useState(&#x27;鸣人&#x27;);<br>  const [zuozhu, setZuozhu] = useState(&#x27;佐助&#x27;);<br>  return (<br>    &lt;Fragment&gt;<br>      &lt;button<br>        onClick=&#123;() =&gt; &#123;<br>          setMingren(mingren + 1);<br>        &#125;&#125;<br>      &gt;<br>        鸣人<br>      &lt;/button&gt;<br>      &lt;button<br>        onClick=&#123;() =&gt; &#123;<br>          setZuozhu(zuozhu + 2);<br>        &#125;&#125;<br>      &gt;<br>        佐助<br>      &lt;/button&gt;<br>      &lt;Child name=&#123;mingren&#125;&gt;&#123;zuozhu&#125;&lt;/Child&gt;<br>    &lt;/Fragment&gt;<br>  );<br>&#125;;<br>export default Demo;<br><br></code></pre></td></tr></table></figure>
<h2 id="轮播图案例"><a href="#轮播图案例" class="headerlink" title="轮播图案例"></a>轮播图案例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//轮播图数据源<br>import React from &#x27;react&#x27;<br>import Swiper from &#x27;../../components/swiper&#x27;<br>class App extends React.Component &#123;<br>    constructor() &#123;<br>        super();<br>        this.state = &#123;<br>            images: [<br>                &#123; src: require(&quot;../../assets/images/banner1.jpg&quot;), url:&quot;https://baidu.com&quot;&#125;,<br>                &#123; src: require(&quot;../../assets/images/banner2.jpg&quot;), url:&quot;https://baidu.com&quot;&#125;,<br>                &#123; src: require(&quot;../../assets/images/banner3.jpg&quot;), url:&quot;https://baidu.com&quot;&#125;,<br>                &#123; src: require(&quot;../../assets/images/banner3.jpg&quot;), url:&quot;https://baidu.com&quot;&#125;,<br>            ]<br>        &#125;<br>    &#125;<br>    render() &#123;<br>        return (<br>            &lt;React.Fragment&gt;<br>                &lt;Swiper data=&#123;this.state.images&#125; /&gt;<br>            &lt;/React.Fragment&gt;<br>        )<br>    &#125;<br>&#125;<br>export default App;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//轮播图UI<br>import React from &#x27;react&#x27;<br>import Hoc from &#x27;./hoc&#x27;<br>import &quot;./style.css&quot;<br>export default Hoc((props) =&gt; &#123;<br>    return (<br>        &lt;div className=&quot;banner&quot;&gt;<br>            &lt;div className=&quot;my-swiper-main&quot; onMouseOver=&#123;props.stop&#125; onMouseOut=&#123;props.autoPlay&#125;&gt;<br>                &#123;<br>                    props.data.length &gt; 0 &amp;&amp; props.data.map((item, index) =&gt; &#123;<br>                        return (<br>                            &lt;div className=&#123;item.active ? &quot;my-slide show&quot; : &quot;my-slide&quot;&#125; key=&#123;index&#125;&gt;<br>                                &lt;a href=&#123;item.url&#125; target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot;&gt;<br>                                    &lt;img src=&#123;item.src&#125; alt=&quot;&quot; /&gt;<br>                                &lt;/a&gt;<br>                            &lt;/div&gt;<br>                        )<br>                    &#125;)<br>                &#125;<br>                &lt;div className=&quot;pagination&quot;&gt;<br>                    &#123;<br>                        props.data.length &gt; 0 &amp;&amp; props.data.map((item, index) =&gt; &#123;<br>                            return (<br>                                &lt;div className=&#123;item.active ? &quot;dot active&quot; : &quot;dot&quot;&#125; key=&#123;index&#125; onClick=&#123;() =&gt; &#123; props.change(index) &#125;&#125;&gt;&lt;/div&gt;<br>                            )<br>                        &#125;)<br>                    &#125;<br>                &lt;/div&gt;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;)<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">//轮播图逻辑<br>import React, &#123; useState, useEffect, useRef, useCallback &#125; from &#x27;react&#x27;;<br>export default function Hoc(WithCompont) &#123;<br>    return function HocCompont(props) &#123;<br>        let [data, setData] = useState([]);<br>        let [isInit, setIsInit] = useState(true)<br>        let [iIndex, setIIndex] = useState(0)<br>        // 创建一个表示，通用容器，专门解决 setInterval<br>        let timer = useRef(null);<br><br>        function change(index) &#123;       //点击切换图片<br>            setIIndex(index)<br>            if (data.length &gt; 0) &#123;<br>                for (let i = 0; i &lt; data.length; i++) &#123;<br>                    if (data[i].active) &#123;<br>                        data[i].active = false;<br>                        break;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            data[index].active = true;<br>            setData(data)<br>        &#125;<br><br>        const autoPlay = useCallback(() =&gt; &#123;      //自动播放<br>            clearInterval(timer.current)<br>            timer.current = setInterval(() =&gt; &#123;<br>                let tmpIndex = iIndex;<br>                if (data.length &gt; 0 &amp;&amp; data) &#123;<br>                    for (let i = 0; i &lt; data.length; i++) &#123;<br>                        if (data[i].active) &#123;<br>                            data[i].active = false;<br>                            break;<br>                        &#125;<br>                    &#125;<br>                    if (tmpIndex &gt;= data.length - 1) &#123;<br>                        tmpIndex = 0;<br>                    &#125; else &#123;<br>                        tmpIndex++<br>                    &#125;<br>                    data[tmpIndex].active = true;<br>                    setIIndex(tmpIndex)<br>                    setData(data)<br>                &#125;<br><br>            &#125;, (3000))<br>        &#125;, [data, iIndex])  //  useState 中用到的值需要放在 第二个参数中<br>        <br>        function stop() &#123;     //鼠标经过清除定时器<br>            clearInterval(timer.current)   <br>        &#125;<br>        useEffect(() =&gt; &#123;<br>            if (props.data &amp;&amp; props.data.length &gt; 0 &amp;&amp; isInit) &#123;<br>                setIsInit(false);<br>                for (let i = 0; i &lt; props.data.length; i++) &#123;<br>                    if (i === 0) &#123;<br>                        props.data[i].active = true;<br>                    &#125; else &#123;<br>                        props.data[i].active = false<br>                    &#125;<br>                &#125;<br>                setData(props.data); //将默认的空数组等于 props.data<br>            &#125;<br>            autoPlay();<br>            return () =&gt; &#123;    //页面离开清除定时器 (页面离开时执行)<br>                clearInterval(timer.current)<br>            &#125;<br>        &#125;, [props.data, isInit, autoPlay]);<br>        let newsPros = &#123;<br>            change: change,<br>            data: data,<br>            stop: stop,<br>            autoPlay: autoPlay,<br>        &#125;<br>        return (<br>            // &lt;WithCompont &#123;...props&#125; data=&#123;data&#125; change=&#123;change&#125; stop=&#123;stop&#125;&gt;&lt;/WithCompont&gt;<br>            &lt;WithCompont &#123;...props&#125; &#123;...newsPros&#125;&gt;&lt;/WithCompont&gt;<br><br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>hooks</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
